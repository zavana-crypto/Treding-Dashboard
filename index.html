<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ZAVANA V19.4 PRO (MATRIX FIXED)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
<!-- EmailJS SDK -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>

<style>
  :root{ 
      /* BINANCE PALETTE */
      --bg-base: #0b0e11; 
      --bg-card: #1e2329; 
      --bg-hover: #2b3139;
      --text-primary: #eaecef; 
      --text-secondary: #848e9c; 
      --accent: #FCD535; /* Binance Yellow */
      --accent-hover: #f0b90b;
      --binance-green: #0ecb81;
      --binance-red: #f6465d;
      --gold: #FFD700; /* Gold Color */
      --border: #2b3139; 
      --card-radius: 6px; 
      --danger: #cf304a;
      --warning: #ffaa00;
  }
   
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
  body { background:var(--bg-base); color:var(--text-primary); font-family:'IBM Plex Sans', sans-serif; margin:0; overflow-x: hidden; overflow-y: auto; height: 100vh; display: flex; flex-direction: column; font-size: 14px; }
   
  /* --- STRATEGY MANIFESTO HEADER --- */
  .manifesto-bar {
      background: #15181d;
      color: var(--text-secondary);
      font-size: 11px;
      padding: 8px 30px;
      border-bottom: 1px solid var(--border);
      text-align: center;
      font-family: 'JetBrains Mono', monospace;
      letter-spacing: -0.2px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
  }
  .manifesto-bar strong { color: var(--accent); }
  .manifesto-text { opacity: 0.8; font-style: italic; }

  /* --- LAYOUT: DESKTOP HEADER --- */
  .navbar-top { height: 64px; background: var(--bg-card); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 30px; justify-content: space-between; position: sticky; top: 0; z-index: 100; }
  .brand { font-family: 'JetBrains Mono', monospace; font-size: 22px; font-weight: 700; color: var(--accent); display: flex; align-items: center; gap: 8px; letter-spacing: -0.5px; }
  .brand span { color: var(--text-primary); font-size: 13px; background: var(--bg-hover); padding: 3px 8px; border-radius: 4px; }
   
  .nav-links { display: flex; gap: 25px; height: 100%; }
  .nav-link { display: flex; align-items: center; color: var(--text-secondary); font-size: 15px; font-weight: 600; cursor: pointer; height: 100%; border-bottom: 3px solid transparent; transition: 0.2s; padding: 0 5px; }
  .nav-link:hover { color: var(--accent); }
  .nav-link.active { color: var(--accent); border-bottom-color: var(--accent); }
   
  .nav-actions { display: flex; gap: 15px; align-items: center; }

  /* --- LAYOUT: MOBILE BOTTOM NAV --- */
  .navbar-bottom { display: none; position: fixed; bottom: 0; left: 0; width: 100%; height: 60px; background: var(--bg-card); border-top: 1px solid var(--border); z-index: 100; justify-content: space-around; align-items: center; padding-bottom: env(safe-area-inset-bottom); }
  .mobile-nav-item { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; color: var(--text-secondary); font-size: 10px; font-weight: 500; width: 100%; height: 100%; }
  .mobile-nav-item svg { width: 20px; height: 20px; fill: currentColor; }
  .mobile-nav-item.active { color: var(--text-primary); }
  .mobile-nav-item.active svg { fill: var(--accent); }

  /* --- MAIN CONTENT (FULL SCREEN) --- */
  .main-content { flex: 1; padding: 25px 30px; margin: 0; width: 100%; max-width: 100%; overflow-y: auto; padding-bottom: 80px; }
  .page { display: none; animation: fadeIn 0.2s ease; }
  .page.active { display: block; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

  /* --- CONTROLS & TOOLBAR --- */
  .toolbar-container { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; align-items: center; justify-content: space-between; }
  .toolbar-group { display: flex; gap: 8px; background: var(--bg-card); padding: 5px; border-radius: 6px; }
   
  .tf-btn { background: transparent; color: var(--text-secondary); border: none; padding: 8px 16px; cursor: pointer; font-weight: 600; font-size: 14px; border-radius: 4px; font-family: 'IBM Plex Sans', sans-serif; transition: 0.2s; }
  .tf-btn:hover { color: var(--text-primary); background: var(--bg-hover); }
  .tf-btn.active { background: var(--bg-hover); color: var(--accent); font-weight: 700; }

  .action-btn { background: var(--bg-hover); color: var(--text-primary); border: none; padding: 10px 16px; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
  .action-btn:hover { background: #3a4049; }
  .wakelock-btn.active { color: var(--accent); background: rgba(252, 213, 53, 0.15); border: 1px solid rgba(252, 213, 53, 0.3); }
  .cloud-btn.synced { color: var(--binance-green); }

  .strategy-badge { font-size: 13px; font-weight: 700; color: var(--text-secondary); font-family: 'JetBrains Mono'; background: var(--bg-card); padding: 8px 14px; border-radius: 4px; border: 1px solid var(--border); }

  /* --- GRID & CARDS (BIGGER) --- */
  .grid { 
      display: grid; 
      /* Min-width increased to 360px to force larger cards on desktop */
      grid-template-columns: repeat(auto-fill, minmax(360px, 1fr)); 
      gap: 20px; 
  }
   
  .card { background: var(--bg-card); border-radius: var(--card-radius); overflow: hidden; display: flex; flex-direction: column; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid transparent; position: relative; }
  .card:hover { transform: translateY(-3px); box-shadow: 0 6px 16px rgba(0,0,0,0.3); border-color: var(--border); }
   
  .card.sniper-mode { border: 1px solid var(--accent); box-shadow: 0 0 20px rgba(252, 213, 53, 0.2); }
  
  /* OVEREXTENDED / FOMO MODE STYLE */
  .card.fomo-mode { border: 1px solid var(--danger); }
  .card.fomo-mode .card-header { opacity: 0.7; }
   
  /* TAGS */
  .sniper-tag { position: absolute; top: 0; right: 0; font-size: 10px; font-weight: 800; padding: 4px 10px; border-bottom-left-radius: 8px; z-index: 10; display: block; letter-spacing: 0.5px; }
   
  .tag-wait-bull { background: #2b3139; color: var(--text-secondary); } 
  .tag-wait-bear { background: #2b3139; color: var(--text-secondary); } 
  
  /* NEW TAGS */
  .tag-intent-buy { background: var(--accent); color: #000; animation: blink-slow 2s infinite; }
  .tag-intent-sell { background: #ffaa00; color: #000; animation: blink-slow 2s infinite; }
  
  .tag-buy { background: var(--binance-green); color: #fff; animation: pulse-green 1s infinite; }
  .tag-sell { background: var(--binance-red); color: #fff; animation: pulse-red 1s infinite; }
  
  .tag-fomo { background: var(--danger); color: #fff; }

  @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(14, 203, 129, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(14, 203, 129, 0); } 100% { box-shadow: 0 0 0 0 rgba(14, 203, 129, 0); } }
  @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(246, 70, 93, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(246, 70, 93, 0); } 100% { box-shadow: 0 0 0 0 rgba(246, 70, 93, 0); } }

  .card-header { padding: 16px 20px; display: flex; justify-content: space-between; align-items: flex-start; border-bottom: 1px solid var(--bg-base); }
  .coin-meta { display: flex; align-items: center; gap: 12px; }
  .coin-icon { width: 36px; height: 36px; border-radius: 50%; }
  .coin-title { font-size: 18px; font-weight: 700; color: var(--text-primary); line-height: 1.2; }
  .coin-vol { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
   
  .price-meta { text-align: right; }
  .price-main { font-size: 20px; font-family: 'JetBrains Mono'; font-weight: 700; color: var(--text-primary); }
  .price-change { font-size: 13px; font-weight: 500; margin-top: 2px;}
  .c-up { color: var(--binance-green); } .c-down { color: var(--binance-red); }

  /* Matrix Bar */
  .matrix-strip { display: flex; gap: 3px; padding: 6px 20px; background: var(--bg-base); }
  .m-dot { flex: 1; height: 5px; border-radius: 2px; background: var(--bg-hover); transition: 0.3s; }
   
  /* UPDATED: Matrix Dot States */
  .m-dot.bull { background: var(--binance-green); box-shadow: 0 0 5px var(--binance-green); }
  .m-dot.bear { background: var(--binance-red); box-shadow: 0 0 5px var(--binance-red); }
  .m-dot.active { height: 7px; margin-top: -1px; border: 1px solid #fff; }
   
  /* NEW: Blinking States for Take Profit / Surge */
  .m-dot.blink-green { background: var(--binance-green); box-shadow: 0 0 8px var(--binance-green); animation: blink-fast 0.5s infinite; }
  .m-dot.blink-red { background: var(--binance-red); box-shadow: 0 0 8px var(--binance-red); animation: blink-fast 0.5s infinite; }
  .m-dot.warning { background: var(--warning); box-shadow: 0 0 5px var(--warning); } /* For Intent Phase */

  /* Chart Area (TALLER) */
  .chart-container { height: 240px; width: 100%; position: relative; background: var(--bg-base); border-bottom: 1px solid var(--bg-base); }
  .visual-arrow { position: absolute; top: 15px; right: 15px; font-size: 24px; z-index: 5; opacity: 0; pointer-events: none; font-weight: 900; }
  .visual-arrow.buy { color: var(--binance-green); opacity: 1; animation: bounceUp 1s infinite; }
  .visual-arrow.sell { color: var(--binance-red); opacity: 1; animation: bounceDown 1s infinite; }
  .visual-msg { position: absolute; bottom: 10px; left: 10px; font-size: 10px; color: var(--text-secondary); background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px; pointer-events: none; z-index: 5; }
  
  @keyframes bounceUp { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
  @keyframes bounceDown { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(6px); } }

  /* Data Row */
  .data-row { display: grid; grid-template-columns: 1fr 1fr 1fr; padding: 14px 20px; gap: 10px; font-family: 'JetBrains Mono'; }
  .data-item { display: flex; flex-direction: column; gap: 4px; }
  .d-label { font-size: 11px; color: var(--text-secondary); text-transform: uppercase; font-weight: 600; }
  .d-val { font-size: 14px; font-weight: 600; color: var(--text-primary); transition: color 0.2s; }
   
  /* Alarm Animations */
  @keyframes blink-slow { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
  @keyframes blink-fast { 0% { opacity: 1; transform: scale(1); } 25% { opacity: 0.5; transform: scale(1.1); } 50% { opacity: 1; transform: scale(1.2); filter: brightness(1.5); } 100% { opacity: 1; transform: scale(1); } }
   
  .alarm-icon { margin-left: 8px; font-size: 16px; display: none; cursor:help; }
  .alarm-active-slow { display: inline-block; color: var(--binance-green); animation: blink-slow 2s infinite ease-in-out; }
  .alarm-active-fast { display: inline-block; color: var(--accent); text-shadow: 0 0 12px var(--accent); animation: blink-fast 0.25s infinite; }
  .alarm-sell-slow { display: inline-block; color: var(--binance-red); animation: blink-slow 2s infinite ease-in-out; }
  .alarm-sell-fast { display: inline-block; color: #ff0000; text-shadow: 0 0 12px #ff0000; animation: blink-fast 0.25s infinite; }
  /* New Alarm State: Intent */
  .alarm-intent { display: inline-block; color: var(--accent); animation: blink-slow 1s infinite; }

  /* Action Footer */
  .card-footer { padding: 16px 20px; display: flex; gap: 15px; background: var(--bg-card); }
  .btn-trade { flex: 1; border: none; border-radius: 4px; padding: 12px 0; font-size: 14px; font-weight: 700; cursor: pointer; text-align: center; text-decoration: none; color: white; transition: 0.2s; opacity: 0.3; letter-spacing: 0.5px; }
  .btn-trade.buy { background: var(--binance-green); }
  .btn-trade.sell { background: var(--binance-red); }
  .btn-trade.active { opacity: 1; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
  .btn-trade:hover { opacity: 0.9; }

  /* Loading Overlay */
  #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-base); z-index: 9999; display: flex; align-items: center; justify-content: center; flex-direction: column; }
  .spinner { width: 50px; height: 50px; border: 5px solid var(--bg-hover); border-top: 5px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

  /* --- TABLE & SETTINGS --- */
  .table-wrapper { background: var(--bg-card); border-radius: var(--card-radius); overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
  table { width: 100%; border-collapse: collapse; min-width: 800px; }
  th { text-align: left; padding: 18px 24px; color: var(--text-secondary); font-size: 13px; font-weight: 600; background: var(--bg-base); border-bottom: 2px solid var(--border); }
  td { padding: 18px 24px; border-top: 1px solid var(--border); color: var(--text-primary); font-size: 14px; }
  tr:hover td { background: var(--bg-hover); }
   
  .settings-box { max-width: 600px; margin: 40px auto; background: var(--bg-card); padding: 40px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
  input, textarea { width: 100%; background: var(--bg-base); border: 1px solid #474d57; color: white; padding: 12px; border-radius: 4px; font-family: inherit; margin-bottom: 20px; font-size: 14px; }
  input:focus, textarea:focus { border-color: var(--accent); }
  label { font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; display: block; font-weight: 500; }
  .btn-primary { width: 100%; background: var(--accent); color: #000; font-weight: 700; padding: 14px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: 0.2s; }
  .btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }

  /* Toast Notification */
  #toast-container { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); z-index: 1000; pointer-events: none; }
  .toast { background: #333; color: #fff; padding: 12px 24px; border-radius: 30px; margin-bottom: 10px; font-size: 14px; opacity: 0; transition: opacity 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.4); text-align: center; font-weight: 500; }
  .toast.show { opacity: 1; }

  /* --- RESPONSIVE MEDIA QUERIES --- */
  @media (max-width: 768px) {
      .navbar-top { display: none; }
      .manifesto-bar { display: none; } /* Hide manifesto on very small screens or stack it */
      .navbar-bottom { display: flex; }
      .main-content { padding: 15px 10px; }
      .grid { grid-template-columns: 1fr; } /* 1 Column on Mobile */
      .card { border-radius: 8px; }
      .chart-container { height: 220px; } 
      .coin-title { font-size: 16px; }
      .price-main { font-size: 18px; }
  }
</style>
</head>
<body>

<!-- LOADING OVERLAY -->
<div id="loading-overlay">
    <div class="spinner"></div>
    <div style="font-family:'JetBrains Mono'; color:var(--text-secondary); font-size:14px; font-weight:600;">AUDITING LOGIC...</div>
</div>

<!-- TOAST CONTAINER -->
<div id="toast-container"></div>

<!-- MANIFESTO BAR -->
<div class="manifesto-bar">
    <strong>MISSION AUDIT:</strong> 
    <span class="manifesto-text">"Saya ingin sistem trading yang memberi alarm sebelum harga bergerak, bukan saat harga sudah bergerak. Fokus pada deteksi niat market, proximity ke demand/supply, dan pembatalan signal jika harga sudah terlalu jauh dari struktur."</span>
</div>

<!-- DESKTOP TOP HEADER -->
<header class="navbar-top">
    <div class="brand">ZAVANA<span>PRO</span></div>
    <div class="nav-links">
        <div class="nav-link active" onclick="showPage('dashboard', this)">Dashboard</div>
        <div class="nav-link" onclick="showPage('screener', this)">Markets</div>
        <div class="nav-link" onclick="showPage('settings', this)">Settings</div>
    </div>
    <div class="nav-actions">
        <button id="wakeLockBtn" class="action-btn wakelock-btn" onclick="toggleWakeLock()">‚ö° ACTIVE</button>
        <button id="cloudBtn" class="action-btn cloud-btn" onclick="toggleCloudSync()">‚òÅ SYNC</button>
    </div>
</header>

<!-- MAIN CONTENT -->
<main class="main-content">
    
    <!-- PAGE 1: DASHBOARD -->
    <div id="page-dashboard" class="page active">
        <div class="toolbar-container">
            <div id="strategyLabel" class="strategy-badge">INIT SYSTEM...</div>
            <div class="toolbar-group" id="tfToolbar"></div>
        </div>

        <div class="grid" id="grid">
            <!-- CARDS INJECTED HERE -->
        </div>
    </div>

    <!-- PAGE 2: MARKETS -->
    <div id="page-screener" class="page">
        <h2 style="font-weight:500; margin-bottom:20px; font-size:24px;">Market Overview</h2>
        <div class="table-wrapper" style="overflow-x:auto;">
            <table>
                <thead>
                    <tr>
                        <th>Pair</th>
                        <th>Price</th>
                        <th>Intent</th>
                        <th>Signal</th>
                        <th>Dist. to Struct</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="screenerTable"></tbody>
            </table>
        </div>
    </div>

    <!-- PAGE 3: SETTINGS -->
    <div id="page-settings" class="page">
        <div class="settings-box">
            <h3 style="margin-top:0; border-bottom:1px solid var(--border); padding-bottom:20px; margin-bottom:30px; font-size:20px;">Preferences</h3>
            
            <label>Watchlist (USDT Pairs, Comma Separated)</label>
            <textarea id="coinInput" rows="4"></textarea>
            
            <label>EmailJS Service ID</label>
            <input type="text" id="emailServiceId">
            <label>EmailJS Template ID</label>
            <input type="text" id="emailTemplateId">
            <label>EmailJS Public Key</label>
            <input type="text" id="emailPublicKey">
            
            <button class="btn-primary" onclick="saveSettings()">Save Configuration</button>
            <div style="text-align:center; margin-top:20px; font-size:12px; color:var(--text-secondary);">
                User ID: <span id="uidDisplay">Local Session</span>
            </div>
        </div>
    </div>

</main>

<!-- MOBILE BOTTOM NAV -->
<nav class="navbar-bottom">
    <div class="mobile-nav-item active" onclick="showPage('dashboard', this)">
        <svg viewBox="0 0 24 24"><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"/></svg>
        <span>Home</span>
    </div>
    <div class="mobile-nav-item" onclick="showPage('screener', this)">
        <svg viewBox="0 0 24 24"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/></svg>
        <span>Markets</span>
    </div>
    <div class="mobile-nav-item" onclick="showPage('settings', this)">
        <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l2.49-1c-.23-.09-.49 0-.61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
        <span>Config</span>
    </div>
</nav>

<script>
/* =========================================
   CORE CONFIG
   ========================================= */
const DEFAULT_COINS = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "XRPUSDT", "DOGEUSDT", "ADAUSDT", "XAUTUSDT", "PAXGUSDT"]; 
let COINS;
try {
    COINS = JSON.parse(localStorage.getItem('zavana_coins'));
    if (!Array.isArray(COINS) || COINS.length === 0) throw new Error("Empty coins");
} catch (e) {
    COINS = DEFAULT_COINS;
    localStorage.setItem('zavana_coins', JSON.stringify(DEFAULT_COINS));
}
COINS = COINS.map(s => s.trim().toUpperCase()).filter(s => s.length > 0);

let EMAIL_CONFIG;
try {
    EMAIL_CONFIG = JSON.parse(localStorage.getItem('zavana_email_config')) || { serviceId: '', templateId: '', publicKey: '' };
} catch(e) {
    EMAIL_CONFIG = { serviceId: '', templateId: '', publicKey: '' };
}

// TIMEFRAMES CONFIG
const TIMEFRAMES = [
  { label: '1m',  ws: '1m',  cc: 'histominute', limit: 500, agg: 1, type: 'HYPER' }, 
  { label: '5m',  ws: '5m',  cc: 'histominute', limit: 500, agg: 5, type: 'SCALP' },
  { label: '15m', ws: '15m', cc: 'histominute', limit: 500, agg: 15, type: 'DAY' },
  { label: '1H',  ws: '1h',  cc: 'histohour',   limit: 500, agg: 1, type: 'DAY' },
  { label: '4H',  ws: '4h',  cc: 'histohour',   limit: 500, agg: 4, type: 'SWING' },
  { label: '1D',  ws: '1d',  cc: 'histoday',    limit: 500, agg: 1, type: 'INVEST' },
  { label: '1W',  ws: '1w',  cc: 'histoday',    limit: 500, agg: 7, type: 'INVEST' }
];

let CURRENT_TF = TIMEFRAMES[2]; 
let ws = null;
const charts = new Map();
const marketData = new Map();
const MTF_MATRIX = new Map(); 
const analysisResults = new Map(); 
const audioCooldown = new Map(); 
const lastAnalysisTime = new Map(); 
let wakeLock = null;
let titleInterval = null;

const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;

/* =========================================
   UI & NAVIGATION
   ========================================= */
function startApp() {
    try {
        renderToolbar();
        renderGrid();
        initSettingsForm(); 
        if(typeof emailjs !== 'undefined' && EMAIL_CONFIG.publicKey) {
            emailjs.init(EMAIL_CONFIG.publicKey);
        }
        changeTimeframe(CURRENT_TF);
        setInterval(updateScreenerTable, 2000); 
        startMatrixScanner();
        setTimeout(() => {
            document.getElementById('loading-overlay').style.display = 'none';
        }, 1000);
    } catch(e) {
        console.error("App Crash:", e);
        document.getElementById('loading-overlay').style.display = 'none';
        showToast("System Init Warning: Check Console");
    }
}

function showToast(message) {
    const container = document.getElementById('toast-container');
    const el = document.createElement('div');
    el.className = 'toast';
    el.textContent = message;
    container.appendChild(el);
    setTimeout(() => el.classList.add('show'), 10);
    setTimeout(() => {
        el.classList.remove('show');
        setTimeout(() => el.remove(), 300);
    }, 3000);
}

function copyText(text) {
    if(!text || text === '--') return;
    const el = document.createElement('textarea');
    el.value = text;
    document.body.appendChild(el);
    el.select();
    document.execCommand('copy');
    document.body.removeChild(el);
    showToast(`Copied: ${text}`);
}

window.showPage = function(pageId, el) {
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.getElementById(`page-${pageId}`).classList.add('active');
    document.querySelectorAll('.nav-link').forEach(n => n.classList.remove('active'));
    if(el && el.classList.contains('nav-link')) el.classList.add('active');
    document.querySelectorAll('.mobile-nav-item').forEach(n => n.classList.remove('active'));
    if(el && el.classList.contains('mobile-nav-item')) el.classList.add('active');
    if(pageId === 'screener') updateScreenerTable();
}

function renderToolbar() {
    const bar = document.getElementById('tfToolbar');
    bar.innerHTML = '';
    TIMEFRAMES.forEach(tf => {
        const btn = document.createElement('button');
        btn.className = `tf-btn ${tf.label === CURRENT_TF.label ? 'active' : ''}`;
        btn.textContent = tf.label;
        btn.onclick = () => changeTimeframe(tf);
        bar.appendChild(btn);
    });
}

function renderGrid() {
    const grid = document.getElementById('grid');
    grid.innerHTML = ''; 
    COINS.forEach(sym => {
        const s = sym.trim().toUpperCase();
        const base = s.replace('USDT','');
        const isGold = s === "PAXGUSDT" || s === "XAUTUSDT";
        let icon = `https://assets.coincap.io/assets/icons/${base.toLowerCase()}@2x.png`;
        if (s === "PAXGUSDT") icon = "https://assets.coincap.io/assets/icons/paxg@2x.png";
        if (s === "XAUTUSDT") icon = "https://s2.coinmarketcap.com/static/img/coins/64x64/5186.png"; 
         
        const card = document.createElement('div');
        card.className = 'card';
        card.id = `card-${s}`;
        card.innerHTML = `
            <div class="sniper-tag" id="tag-${s}">INIT...</div>
            <div class="card-header">
                <div class="coin-meta">
                    <img src="${icon}" class="coin-icon" onerror="this.style.display='none'">
                    <div>
                        <div class="coin-title" style="${isGold?'color:var(--gold)':''}">
                            ${base}/USDT <span id="trend-arrow-${s}" style="font-weight:bold; font-size:14px; margin-left:4px;"></span>
                            ${isGold ? '<span style="font-size:10px; background:#FFD700; color:black; padding:1px 3px; border-radius:2px; margin-left:4px;">GOLD</span>' : ''}
                        </div>
                        <div class="coin-vol">Vol: <span id="vol-${s}">--</span></div>
                    </div>
                </div>
                <div class="price-meta">
                    <div class="price-main" id="price-${s}">---</div>
                    <div class="price-change" id="chg-${s}">--%</div>
                </div>
            </div>
            
            <div class="matrix-strip">
                ${TIMEFRAMES.map(t => `<div id="mtx-${s}-${t.label}" class="m-dot" title="${t.label}"></div>`).join('')}
            </div>

            <div class="chart-container">
                <div id="chart-${s}" style="width:100%; height:100%"></div>
                <div id="visual-${s}" class="visual-arrow">‚û§</div>
                <div id="msg-${s}" class="visual-msg">WAITING FOR INTENT</div>
            </div>
            
            <div class="data-row">
                <div class="data-item">
                    <span class="d-label">Struct Dist.</span>
                    <span class="d-val" id="dist-${s}">--</span>
                </div>
                <div class="data-item">
                    <span class="d-label">Stop Loss</span>
                    <span class="d-val" id="sl-${s}">--</span>
                </div>
                <div class="data-item" style="text-align:right;">
                    <span class="d-label">Take Profit</span>
                    <div>
                        <span class="d-val" id="tp-${s}" style="color:var(--binance-green);">--</span>
                        <span id="alarm-${s}" class="alarm-icon">üîî</span>
                    </div>
                </div>
            </div>

            <div class="card-footer">
                <a href="https://www.binance.com/en/trade/${base}_USDT?type=spot" target="_blank" class="btn-trade buy" id="btn-buy-${s}">BUY <span id="sc-buy-${s}">0.0</span></a>
                <a href="https://www.binance.com/en/trade/${base}_USDT?type=spot" target="_blank" class="btn-trade sell" id="btn-sell-${s}">SELL <span id="sc-sell-${s}">0.0</span></a>
            </div>
        `;
        grid.appendChild(card);
        
        // Chart Setup
        const cont = document.getElementById(`chart-${s}`);
        const chart = LightweightCharts.createChart(cont, {
            layout: { backgroundColor: '#0b0e11', textColor: '#848e9c', fontSize: 11, fontFamily: 'JetBrains Mono' }, 
            grid: { vertLines: { color: '#1e2329' }, horzLines: { color: '#1e2329' } },
            rightPriceScale: { borderVisible: false, scaleMargins: { top: 0.1, bottom: 0.1 } },
            timeScale: { visible: false, borderVisible: false },
            crosshair: { vertLine: { visible: false }, horzLine: { visible: false } },
            handleScroll: false, handleScale: false
        });
        const candleColorUp = isGold ? '#FFD700' : '#0ECB81'; 
        const series = chart.addCandlestickSeries({ upColor: candleColorUp, downColor: '#F6465D', borderVisible: false, wickVisible: true });
        const zoneSeries = chart.addLineSeries({ color: 'rgba(255,255,255,0.2)', lineWidth: 1, lineStyle: 2, crosshairMarkerVisible: false, lastValueVisible: false, priceLineVisible: false });
        
        new ResizeObserver(e => { if(e[0]) chart.applyOptions({ width: e[0].contentRect.width, height: e[0].contentRect.height }); }).observe(cont);
        
        charts.set(s, { chart, series, zoneSeries });
        marketData.set(s, []);
    });
}

function updateScreenerTable() {
    const tbody = document.getElementById('screenerTable');
    if(!document.getElementById('page-screener').classList.contains('active')) return;
    
    let html = '';
    COINS.forEach(sym => {
        const res = analysisResults.get(sym) || {};
        const base = sym.replace('USDT','');
        
        let intentClass = '';
        if (res.intent === 'BULL_PREPARE') intentClass = 'c-up';
        if (res.intent === 'BEAR_PREPARE') intentClass = 'c-down';
        
        let sigClass = '';
        if (res.signal === 'BUY') sigClass = 'c-up';
        if (res.signal === 'SELL') sigClass = 'c-down';
        if (res.isOverextended) sigClass = 'c-down';

        html += `
            <tr style="border-bottom:1px solid var(--border);">
                <td><b style="color:var(--text-primary);">${base}</b></td>
                <td style="font-family:'JetBrains Mono';">${res.price ? res.price.toFixed(res.price<1?4:2) : '---'}</td>
                <td class="${intentClass}" style="font-size:11px; font-weight:700;">${res.intent || 'NEUTRAL'}</td>
                <td class="${sigClass}" style="font-size:11px;">${res.isOverextended ? 'FOMO/SKIP' : (res.signal || 'WAIT')}</td>
                <td style="font-family:'JetBrains Mono'; font-size:11px;">${res.distRatio ? res.distRatio.toFixed(1) + 'x ATR' : '--'}</td>
                <td><a href="https://www.binance.com/en/trade/${base}_USDT" target="_blank" style="color:var(--accent); text-decoration:none;">VIEW</a></td>
            </tr>
        `;
    });
    tbody.innerHTML = html;
}

/* =========================================
   DATA & STRATEGY (AUDITED: ANTI-FOMO & INTENT)
   ========================================= */
async function changeTimeframe(tf) {
    CURRENT_TF = tf;
    document.querySelectorAll('.tf-btn').forEach(b => b.classList.toggle('active', b.textContent === tf.label));
    
    const sLabel = document.getElementById('strategyLabel');
    sLabel.textContent = `MODE: ${tf.type} (${tf.label})`;
    sLabel.style.color = tf.type==='HYPER' ? 'var(--binance-red)' : 'var(--text-primary)';
    
    if(ws) ws.close();
    
    for (const sym of COINS) {
        await new Promise(r => setTimeout(r, 1000)); 
        const hist = await fetchHistory(sym, tf.ws, tf.limit);
        if(hist && hist.length > 0) { 
            marketData.set(sym, hist);
            const cObj = charts.get(sym);
            if(cObj) {
                cObj.series.setData(hist);
                cObj.chart.timeScale().fitContent(); 
                analyze(sym, hist, tf);
            }
        }
    }
    
    const streams = COINS.map(c => `${c.toLowerCase()}@kline_${tf.ws}`).join('/');
    ws = new WebSocket(`wss://stream.binance.com:9443/stream?streams=${streams}`);
    ws.onmessage = (e) => {
        try {
            const msg = JSON.parse(e.data);
            const k = msg.data.k;
            const c = { time: k.t/1000, open: +k.o, high: +k.h, low: +k.l, close: +k.c, volume: +k.v };
            handleStream(msg.data.s, c);
        } catch(err) {}
    };
}

// CHANGED: 3-Stage Fetch Strategy (Direct -> Proxy -> Backup)
async function fetchHistory(s, interval, lim) {
    try {
        const url = `https://api.binance.com/api/v3/klines?symbol=${s}&interval=${interval}&limit=${lim}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Binance Blocked");
        return await parseBinance(res);
    } catch(e) { 
        try {
             const url = `https://api.binance.com/api/v3/klines?symbol=${s}&interval=${interval}&limit=${lim}`;
             const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
             const res = await fetch(proxyUrl);
             if (!res.ok) throw new Error("Proxy Blocked");
             return await parseBinance(res);
        } catch (e2) {
             console.warn("Binance Proxy failed, switching to CryptoCompare...");
             return await fetchHistoryBackup(s, interval, lim);
        }
    }
}

async function parseBinance(res) {
    const raw = await res.json();
    return raw.map(d => ({ time: d[0] / 1000, open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]) }));
}

async function fetchHistoryBackup(s, interval, lim) {
    let endpoint = 'histominute';
    let agg = 1;
    if(interval === '1m') { endpoint = 'histominute'; agg = 1; }
    if(interval === '5m') { endpoint = 'histominute'; agg = 5; }
    if(interval === '15m') { endpoint = 'histominute'; agg = 15; }
    if(interval === '1h') { endpoint = 'histohour'; agg = 1; }
    if(interval === '4h') { endpoint = 'histohour'; agg = 4; }
    if(interval === '1d') { endpoint = 'histoday'; agg = 1; }
    if(interval === '1w') { endpoint = 'histoday'; agg = 7; }

    try {
        const base = s.replace('USDT','');
        const res = await fetch(`https://min-api.cryptocompare.com/data/v2/${endpoint}?fsym=${base}&tsym=USDT&limit=${lim}&aggregate=${agg}`);
        const j = await res.json();
        if(j.Response === "Error") return [];
        return j.Data.Data.map(d=>({time:d.time,open:d.open,high:d.high,low:d.low,close:d.close,volume:d.volumeto}));
    } catch(e) { return []; }
}

function handleStream(sym, candle) {
    const arr = marketData.get(sym);
    if(!arr) return;
    const last = arr[arr.length-1];
    
    if (candle.time === last.time) {
        arr[arr.length-1] = candle; 
    } else if (candle.time > last.time) {
        arr.push(candle); 
        if(arr.length > 500) arr.shift();
    }
    
    const pEl = document.getElementById(`price-${sym}`);
    if(pEl) {
        const prev = parseFloat(pEl.getAttribute('data-p')||0);
        if(candle.close !== prev) {
            pEl.textContent = candle.close.toFixed(candle.close<1?4:2);
            pEl.className = `price-main ${candle.close>=prev?'c-up':'c-down'}`;
            pEl.setAttribute('data-p', candle.close);
        }
    }

    const cObj = charts.get(sym);
    if(cObj) cObj.series.update(candle);
    
    const now = Date.now();
    const lastRun = lastAnalysisTime.get(sym) || 0;
    if (now - lastRun > 1000) {
        analyze(sym, arr, CURRENT_TF);
        lastAnalysisTime.set(sym, now);
    }
}

/* =========================================
   REVISED ANALYZE FUNCTION (AUDITED LOGIC)
   ========================================= */
function analyze(sym, data, tf = CURRENT_TF, isBackground = false) {
    if(data.length < 50) return; 

    const last = data[data.length-1];
    
    // 1. DATA PREP
    const atr = calcATR(data, 14);
    const sma20 = calcSMA(data, 20);
    const ema21 = calcEMA(data, 21);
    const supportBand = Math.max(sma20, ema21); 
    const resistBand = Math.min(sma20, ema21);
    
    // 2. STRUCTURE & TREND
    const smc = findOrderBlocksAdvanced(data, 5);
    const vStopBig = calcVolStopSeries(data, 20, 3.0);
    const isUptrend = vStopBig.uptrend;
    
    // 3. MOMENTUM
    const obvOsc = calcOBVOscillator(data, 10, 10);
    const obvVal = obvOsc[obvOsc.length-1];
    
    // === AUDIT LOGIC (ANTI-FOMO) ===
    let intent = "NEUTRAL";
    let signal = "WAIT";
    let isOverextended = false;
    let distRatio = 0;
    
    let nearestSupport = smc.bullOB ? smc.bullOB.top : supportBand;
    let nearestResist = smc.bearOB ? smc.bearOB.bottom : resistBand;
    
    if (isUptrend) {
        const distToSup = last.close - nearestSupport;
        distRatio = distToSup / atr;
        if (distRatio > 2.5) isOverextended = true;
    } else {
        const distToRes = nearestResist - last.close;
        distRatio = distToRes / atr;
        if (distRatio > 2.5) isOverextended = true;
    }
    
    if (isUptrend && !isOverextended) {
        if (last.close <= nearestSupport + (atr * 1.5)) intent = "BULL_PREPARE";
    } else if (!isUptrend && !isOverextended) {
        if (last.close >= nearestResist - (atr * 1.5)) intent = "BEAR_PREPARE";
    }
    
    let bScore = 0; let sScore = 0;
    
    // RAW SCORING (FOR MATRIX VISUAL - RESTORED LOGIC)
    // Even if intent is not perfect, we show trend state in Matrix
    // The previous version had raw scores, so we use similar logic for Matrix populating
    // Trend (2) + Momentum (1) + Structure (2)
    
    if (isUptrend) bScore += 2; else sScore += 2;
    if (obvVal > -40) bScore += 1;
    if (obvVal < 40) sScore += 1;
    
    // EXECUTION SIGNAL (STRICT)
    if (intent === "BULL_PREPARE") {
        if (last.close > last.open) bScore += 1; 
        if (last.low < nearestSupport) bScore += 2; 
        if (bScore >= 4) signal = "BUY"; // Higher threshold for strict entry
    }
    
    if (intent === "BEAR_PREPARE") {
        if (last.close < last.open) sScore += 1; 
        if (last.high > nearestResist) sScore += 2; 
        if (sScore >= 4) signal = "SELL"; 
    }

    // MATRIX LOGIC (RESTORED): Use broader definition for heatmap
    // If Trend is UP and Momentum is OK, show Green Dot (even if no strict Buy signal yet)
    let matrixSig = "WAIT";
    if (bScore >= 3) matrixSig = "BUY";
    else if (sScore >= 3) matrixSig = "SELL";
    MTF_MATRIX.set(`${sym}_${tf.label}`, matrixSig); // <--- RESTORED LINE

    // SL/TP CALC
    let tp = 0, sl = 0;
    if (signal === "BUY") {
        sl = nearestSupport - atr;
        tp = smc.bearOB ? smc.bearOB.bottom : last.close + (atr * 4);
    } else if (signal === "SELL") {
        sl = nearestResist + atr;
        tp = smc.bullOB ? smc.bullOB.top : last.close - (atr * 4);
    } else {
        sl = isUptrend ? nearestSupport : nearestResist;
        tp = isUptrend ? last.close + (atr*3) : last.close - (atr*3);
    }

    const res = { signal, intent, isOverextended, distRatio, price: last.close, tp, sl, bScore, sScore };
    analysisResults.set(sym, res);

    if (isBackground) { updateMatrixUI(sym); return; }
    
    // VISUALS
    const cObj = charts.get(sym);
    if(cObj) {
        const zoneLevel = isUptrend ? nearestSupport : nearestResist;
        cObj.zoneSeries.setData(data.map(d => ({ time: d.time, value: zoneLevel })));
        
        let markers = [];
        if (intent === "BULL_PREPARE") markers.push({ time: last.time, position: 'belowBar', color: '#FCD535', shape: 'circle', text: 'PREP' });
        if (intent === "BEAR_PREPARE") markers.push({ time: last.time, position: 'aboveBar', color: '#FCD535', shape: 'circle', text: 'PREP' });
        if (signal === "BUY") markers.push({ time: last.time, position: 'belowBar', color: '#0ECB81', shape: 'arrowUp', text: 'GO' });
        if (signal === "SELL") markers.push({ time: last.time, position: 'aboveBar', color: '#F6465D', shape: 'arrowDown', text: 'GO' });
        cObj.series.setMarkers(markers);
    }
    
    updateCardUI(sym, res, atr);
    updateMatrixUI(sym);
    
    // ALARM HANDLER (BROWSER BAR FLASH + SOUND)
    if (signal !== "WAIT") {
        triggerAlert(sym, signal);
        flashTitle(`üö® ${signal} ${sym}`, true);
    } else if (intent !== "NEUTRAL") {
        triggerAlert(sym, "PREPARE");
        flashTitle(`‚ö†Ô∏è PREP ${sym}`, false);
    } else {
        flashTitle("", false); // Stop flashing if neutral
    }
}

/* =========================================
   MATH HELPERS
   ========================================= */

function calcVolStopSeries(data, length, factor) {
    let max = data[0].close;
    let min = data[0].close;
    let uptrend = true;
    let stop = data[0].close - (calcTR(data[0], data[0]) * factor);
    for(let i=1; i<data.length; i++) {
        const curr = data[i];
        const tr = Math.max(curr.high - curr.low, Math.abs(curr.high - data[i-1].close), Math.abs(curr.low - data[i-1].close));
        const atrM = tr * factor;
        max = Math.max(max, curr.close);
        min = Math.min(min, curr.close);
        if (uptrend) stop = Math.max(stop, max - atrM);
        else stop = Math.min(stop, min + atrM);
        const newUptrend = (curr.close - stop) >= 0;
        if (newUptrend !== uptrend) {
            max = curr.close; min = curr.close; uptrend = newUptrend;
            stop = uptrend ? max - atrM : min + atrM;
        }
    }
    return { stop, uptrend };
}

function calcTR(curr, prev) { return Math.max(curr.high - curr.low, Math.abs(curr.high - prev.close), Math.abs(curr.low - prev.close)); }
function calcOBVOscillator(data, n1, n2) {
    let obv = [0];
    for(let i=1; i<data.length; i++) {
        const change = data[i].close - data[i-1].close;
        const sign = change > 0 ? 1 : (change < 0 ? -1 : 0);
        obv.push(obv[i-1] + (sign * data[i].volume));
    }
    const emaOBV = calcEMAArray(obv, n1);
    let absDiff = [];
    for(let i=0; i<obv.length; i++) absDiff.push(Math.abs(obv[i] - emaOBV[i]));
    const emaAbsDiff = calcEMAArray(absDiff, n1);
    let out = [];
    for(let i=0; i<obv.length; i++) {
        const denom = 0.015 * emaAbsDiff[i];
        if (denom === 0) out.push(0); else out.push( (obv[i] - emaOBV[i]) / denom );
    }
    return calcEMAArray(out, n2);
}
function calcEMAArray(dataArr, period) {
    let results = [];
    let k = 2 / (period + 1);
    let ema = dataArr[0];
    results.push(ema);
    for(let i=1; i<dataArr.length; i++) { ema = (dataArr[i] * k) + (ema * (1 - k)); results.push(ema); }
    return results;
}
function findOrderBlocksAdvanced(data, periods = 5) {
    if(data.length < 50) return {};
    let bullOB = null; let bearOB = null;
    for(let i = data.length - 1 - periods; i > 1; i--) {
        const obCandle = data[i];
        if (!bullOB && obCandle.close < obCandle.open) { 
            let allGreen = true;
            for(let j=1; j<=periods; j++) { if(data[i+j].close <= data[i+j].open) allGreen = false; }
            if(allGreen) bullOB = { top: Math.max(obCandle.open, obCandle.close), bottom: obCandle.low, time: obCandle.time };
        }
        if (!bearOB && obCandle.close > obCandle.open) { 
            let allRed = true;
            for(let j=1; j<=periods; j++) { if(data[i+j].close >= data[i+j].open) allRed = false; }
            if(allRed) bearOB = { top: obCandle.high, bottom: Math.min(obCandle.open, obCandle.close), time: obCandle.time };
        }
        if(bullOB && bearOB) break;
    }
    return { bullOB, bearOB };
}
function calcSMA(d, p) { if(d.length<p) return d[d.length-1].close; let s=0; for(let i=d.length-p; i<d.length; i++) s+=d[i].close; return s/p; }
function calcEMA(d,p){if(d.length<p)return null;const k=2/(p+1);let e=d[0].close;for(let i=1;i<d.length;i++)e=(d[i].close*k)+(e*(1-k));return e;}
function calcATR(d,p){if(d.length<p+1)return 0;let s=0;for(let i=d.length-p;i<d.length;i++)s+=Math.max(d[i].high-d[i].low,Math.abs(d[i].high-d[i-1].close),Math.abs(d[i].low-d[i-1].close));return s/p;}

// FIXED: updateCardUI with SAFETY CHECKS
function updateCardUI(sym, res, atr) {
    const card = document.getElementById(`card-${sym}`);
    if(!card) return;

    // Helper: Safely get element and set text/style
    const setText = (id, txt) => { const el = document.getElementById(id); if(el) el.textContent = txt; };
    const setStyle = (id, prop, val) => { const el = document.getElementById(id); if(el) el.style[prop] = val; };
    const setClass = (id, cls) => { const el = document.getElementById(id); if(el) el.className = cls; };
    
    // Direct elements
    const tag = card.querySelector('.sniper-tag');
    const msgEl = document.getElementById(`msg-${sym}`);
    const visualEl = document.getElementById(`visual-${sym}`);
    const alarmEl = document.getElementById(`alarm-${sym}`);
    
    // RESET CLASSES
    card.classList.remove('fomo-mode', 'sniper-mode');
    if(tag) tag.className = 'sniper-tag';
    if(visualEl) { visualEl.className = 'visual-arrow'; visualEl.textContent = '‚û§'; }
    if(alarmEl) alarmEl.className = 'alarm-icon';

    // 1. OVEREXTENDED STATE (FOMO)
    if (res.isOverextended) {
        card.classList.add('fomo-mode');
        if(tag) { tag.textContent = 'OVEREXTENDED (SKIP)'; tag.classList.add('tag-fomo'); }
        if(msgEl) { 
            msgEl.textContent = `TOO FAR (${res.distRatio.toFixed(1)}x ATR)`; 
            msgEl.style.color = '#ff4444'; 
        }
        return; 
    }

    // 2. SIGNAL STATE (EXECUTION)
    if (res.signal === 'BUY') {
        if(tag) { tag.textContent = 'EXECUTE BUY'; tag.classList.add('tag-buy'); }
        if(msgEl) { msgEl.textContent = 'CONFIRMED ENTRY'; msgEl.style.color = '#0ecb81'; }
        if(visualEl) { visualEl.textContent = '‚ñ≤'; visualEl.className = 'visual-arrow buy'; }
        if(alarmEl) alarmEl.className = 'alarm-icon alarm-active-fast';
        card.classList.add('sniper-mode');
    } else if (res.signal === 'SELL') {
        if(tag) { tag.textContent = 'EXECUTE SELL'; tag.classList.add('tag-sell'); }
        if(msgEl) { msgEl.textContent = 'CONFIRMED ENTRY'; msgEl.style.color = '#f6465d'; }
        if(visualEl) { visualEl.textContent = '‚ñº'; visualEl.className = 'visual-arrow sell'; }
        if(alarmEl) alarmEl.className = 'alarm-icon alarm-sell-fast';
        card.classList.add('sniper-mode');
    } 
    // 3. INTENT STATE (PRE-SIGNAL)
    else if (res.intent === 'BULL_PREPARE') {
        if(tag) { tag.textContent = 'PREPARE BUY'; tag.classList.add('tag-intent-buy'); }
        if(msgEl) { msgEl.textContent = `IN BUY ZONE (${res.distRatio.toFixed(1)}x ATR)`; msgEl.style.color = '#FCD535'; }
        if(alarmEl) alarmEl.className = 'alarm-icon alarm-intent';
    } else if (res.intent === 'BEAR_PREPARE') {
        if(tag) { tag.textContent = 'PREPARE SELL'; tag.classList.add('tag-intent-sell'); }
        if(msgEl) { msgEl.textContent = `IN SELL ZONE (${res.distRatio.toFixed(1)}x ATR)`; msgEl.style.color = '#FCD535'; }
        if(alarmEl) alarmEl.className = 'alarm-icon alarm-intent';
    } else {
        if(tag) { tag.textContent = 'WAITING SETUP'; tag.classList.add('tag-wait-bull'); }
        if(msgEl) { msgEl.textContent = 'NO CLEAR INTENT'; msgEl.style.color = '#848e9c'; }
    }
    
    // BTN UPDATE
    const btnBuy = document.getElementById(`btn-buy-${sym}`);
    if(btnBuy) btnBuy.className = `btn-trade buy ${res.signal==='BUY'?'active':''}`;
    const btnSell = document.getElementById(`btn-sell-${sym}`);
    if(btnSell) btnSell.className = `btn-trade sell ${res.signal==='SELL'?'active':''}`;
    
    // UPDATE DATA SAFELY
    setText(`sc-buy-${sym}`, res.bScore.toFixed(0));
    setText(`sc-sell-${sym}`, res.sScore.toFixed(0));
    setText(`e-${sym}`, res.price.toFixed(res.price<1?4:2));
    setText(`dist-${sym}`, res.distRatio.toFixed(1) + 'x ATR');
    setText(`tp-${sym}`, res.tp.toFixed(res.price<1?4:2));
    setText(`sl-${sym}`, res.sl.toFixed(res.price<1?4:2));
}

function updateMatrixUI(sym) {
    TIMEFRAMES.forEach(tf => {
        const el = document.getElementById(`mtx-${sym}-${tf.label}`);
        if(el) {
            const rawSig = MTF_MATRIX.get(`${sym}_${tf.label}`) || 'WAIT';
            const sig = rawSig.replace('_SURGE', '');
            el.className = 'm-dot';
            if (sig === 'BUY') el.classList.add('bull');
            else if (sig === 'SELL') el.classList.add('bear');
            
            if(tf.label === CURRENT_TF.label) el.classList.add('active');
        }
    });
}

function startMatrixScanner() {
    let coinIdx = 0, tfIdx = 0;
    setInterval(async () => {
        if(COINS.length === 0) return;
        const sym = COINS[coinIdx];
        const tf = TIMEFRAMES[tfIdx];
        if(tf.label !== CURRENT_TF.label) {
            try {
                const hist = await fetchHistory(sym, tf.ws, 60);
                if(hist.length > 50) analyze(sym, hist, tf, true);
            } catch(e) {}
        }
        tfIdx++;
        if(tfIdx >= TIMEFRAMES.length) { tfIdx = 0; coinIdx++; if(coinIdx >= COINS.length) coinIdx = 0; }
    }, 1000); 
}

/* =========================================
   SETTINGS & UTILS
   ========================================= */
function initSettingsForm() {
    document.getElementById('coinInput').value = COINS.join(', ');
    document.getElementById('emailServiceId').value = EMAIL_CONFIG.serviceId;
    document.getElementById('emailTemplateId').value = EMAIL_CONFIG.templateId;
    document.getElementById('emailPublicKey').value = EMAIL_CONFIG.publicKey;
}
window.saveSettings = function() {
    const raw = document.getElementById('coinInput').value;
    COINS = raw.split(',').map(s => s.trim().toUpperCase()).filter(s => s.length > 0);
    EMAIL_CONFIG.serviceId = document.getElementById('emailServiceId').value;
    EMAIL_CONFIG.templateId = document.getElementById('emailTemplateId').value;
    EMAIL_CONFIG.publicKey = document.getElementById('emailPublicKey').value;
    localStorage.setItem('zavana_coins', JSON.stringify(COINS));
    localStorage.setItem('zavana_email_config', JSON.stringify(EMAIL_CONFIG));
    saveCloudData();
    location.reload(); 
}
async function toggleWakeLock() {
    if ('wakeLock' in navigator) {
        try { wakeLock ? (await wakeLock.release(), wakeLock=null) : (wakeLock=await navigator.wakeLock.request('screen')); } catch(e){}
        const btn = document.getElementById('wakeLockBtn');
        if(wakeLock) { btn.classList.add('active'); btn.innerHTML = '‚ö° ON'; } else { btn.classList.remove('active'); btn.innerHTML = '‚ö° OFF'; }
    }
}

// BROWSER TITLE FLASHING
function flashTitle(msg, isUrgent) {
    if(!msg) { 
        if(titleInterval) clearInterval(titleInterval); 
        document.title = "ZAVANA V19.4 PRO (MATRIX FIXED)"; 
        return; 
    }
    if(titleInterval) clearInterval(titleInterval);
    let state = false;
    titleInterval = setInterval(() => {
        document.title = state ? msg : (isUrgent ? "üî¥ ACTION REQUIRED" : "‚ö†Ô∏è MARKET ALERT");
        state = !state;
    }, 1000);
}

function triggerAlert(sym, type) {
    const now = Date.now();
    if(now - (audioCooldown.get(sym)||0) > 60000) {
        if(Notification.permission==='granted') new Notification(`ZAVANA ${type}: ${sym}`);
        playBeep(); audioCooldown.set(sym, now);
    }
}
async function playBeep() {
    try { if(!audioCtx) audioCtx = new AudioContext(); if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc=audioCtx.createOscillator(), g=audioCtx.createGain(); osc.connect(g); g.connect(audioCtx.destination);
    osc.frequency.setValueAtTime(880,audioCtx.currentTime); g.gain.setValueAtTime(0.05,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.2);
    osc.start(); osc.stop(audioCtx.currentTime+0.2); } catch(e){}
}
document.addEventListener('click', () => { if(!audioCtx) audioCtx = new AudioContext(); });

let auth, db, user;
async function toggleCloudSync() { showToast("Cloud Sync Active (Stub Mode)"); } 
async function saveCloudData() {}

const checkLib = setInterval(() => { if (typeof LightweightCharts !== 'undefined') { clearInterval(checkLib); startApp(); } }, 200);
</script>
</body>
</html>
