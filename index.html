<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ZAVANA V19.1 PRO (REAL MOMENTUM LOGIC)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
<!-- EmailJS SDK -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>

<style>
  :root{ 
      /* BINANCE PALETTE */
      --bg-base: #0b0e11; 
      --bg-card: #1e2329; 
      --bg-hover: #2b3139;
      --text-primary: #eaecef; 
      --text-secondary: #848e9c; 
      --accent: #FCD535; /* Binance Yellow */
      --accent-hover: #f0b90b;
      --binance-green: #0ecb81;
      --binance-red: #f6465d;
      --gold: #FFD700; /* Gold Color */
      --border: #2b3139; 
      --card-radius: 6px; 
  }
   
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
  body { background:var(--bg-base); color:var(--text-primary); font-family:'IBM Plex Sans', sans-serif; margin:0; overflow-x: hidden; overflow-y: auto; height: 100vh; display: flex; flex-direction: column; font-size: 14px; }
   
  /* --- LAYOUT: DESKTOP HEADER --- */
  .navbar-top { height: 64px; background: var(--bg-card); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 30px; justify-content: space-between; position: sticky; top: 0; z-index: 100; }
  .brand { font-family: 'JetBrains Mono', monospace; font-size: 22px; font-weight: 700; color: var(--accent); display: flex; align-items: center; gap: 8px; letter-spacing: -0.5px; }
  .brand span { color: var(--text-primary); font-size: 13px; background: var(--bg-hover); padding: 3px 8px; border-radius: 4px; }
   
  .nav-links { display: flex; gap: 25px; height: 100%; }
  .nav-link { display: flex; align-items: center; color: var(--text-secondary); font-size: 15px; font-weight: 600; cursor: pointer; height: 100%; border-bottom: 3px solid transparent; transition: 0.2s; padding: 0 5px; }
  .nav-link:hover { color: var(--accent); }
  .nav-link.active { color: var(--accent); border-bottom-color: var(--accent); }
   
  .nav-actions { display: flex; gap: 15px; align-items: center; }

  /* --- LAYOUT: MOBILE BOTTOM NAV --- */
  .navbar-bottom { display: none; position: fixed; bottom: 0; left: 0; width: 100%; height: 60px; background: var(--bg-card); border-top: 1px solid var(--border); z-index: 100; justify-content: space-around; align-items: center; padding-bottom: env(safe-area-inset-bottom); }
  .mobile-nav-item { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; color: var(--text-secondary); font-size: 10px; font-weight: 500; width: 100%; height: 100%; }
  .mobile-nav-item svg { width: 20px; height: 20px; fill: currentColor; }
  .mobile-nav-item.active { color: var(--text-primary); }
  .mobile-nav-item.active svg { fill: var(--accent); }

  /* --- MAIN CONTENT (FULL SCREEN) --- */
  .main-content { flex: 1; padding: 25px 30px; margin: 0; width: 100%; max-width: 100%; overflow-y: auto; padding-bottom: 80px; }
  .page { display: none; animation: fadeIn 0.2s ease; }
  .page.active { display: block; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

  /* --- CONTROLS & TOOLBAR --- */
  .toolbar-container { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; align-items: center; justify-content: space-between; }
  .toolbar-group { display: flex; gap: 8px; background: var(--bg-card); padding: 5px; border-radius: 6px; }
   
  .tf-btn { background: transparent; color: var(--text-secondary); border: none; padding: 8px 16px; cursor: pointer; font-weight: 600; font-size: 14px; border-radius: 4px; font-family: 'IBM Plex Sans', sans-serif; transition: 0.2s; }
  .tf-btn:hover { color: var(--text-primary); background: var(--bg-hover); }
  .tf-btn.active { background: var(--bg-hover); color: var(--accent); font-weight: 700; }

  .action-btn { background: var(--bg-hover); color: var(--text-primary); border: none; padding: 10px 16px; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
  .action-btn:hover { background: #3a4049; }
  .wakelock-btn.active { color: var(--accent); background: rgba(252, 213, 53, 0.15); border: 1px solid rgba(252, 213, 53, 0.3); }
  .cloud-btn.synced { color: var(--binance-green); }

  .strategy-badge { font-size: 13px; font-weight: 700; color: var(--text-secondary); font-family: 'JetBrains Mono'; background: var(--bg-card); padding: 8px 14px; border-radius: 4px; border: 1px solid var(--border); }

  /* --- GRID & CARDS (BIGGER) --- */
  .grid { 
      display: grid; 
      /* Min-width increased to 360px to force larger cards on desktop */
      grid-template-columns: repeat(auto-fill, minmax(360px, 1fr)); 
      gap: 20px; 
  }
   
  .card { background: var(--bg-card); border-radius: var(--card-radius); overflow: hidden; display: flex; flex-direction: column; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid transparent; position: relative; }
  .card:hover { transform: translateY(-3px); box-shadow: 0 6px 16px rgba(0,0,0,0.3); border-color: var(--border); }
   
  .card.sniper-mode { border: 1px solid var(--accent); box-shadow: 0 0 20px rgba(252, 213, 53, 0.2); }
   
  /* TAGS */
  .sniper-tag { position: absolute; top: 0; right: 0; font-size: 10px; font-weight: 800; padding: 4px 10px; border-bottom-left-radius: 8px; z-index: 10; display: block; letter-spacing: 0.5px; }
   
  .tag-wait-bull { background: var(--accent); color: #000; } 
  .tag-wait-bear { background: #474d57; color: #fff; } 
  .tag-buy { background: var(--binance-green); color: #fff; animation: pulse-green 1s infinite; }
  .tag-sell { background: var(--binance-red); color: #fff; animation: pulse-red 1s infinite; }
  
  /* NEW: PREPARE TAG (ORANGE) */
  .tag-prepare { background: #FF9800; color: #000; animation: blink-slow 1.5s infinite; }

  @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(14, 203, 129, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(14, 203, 129, 0); } 100% { box-shadow: 0 0 0 0 rgba(14, 203, 129, 0); } }
  @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(246, 70, 93, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(246, 70, 93, 0); } 100% { box-shadow: 0 0 0 0 rgba(246, 70, 93, 0); } }

  .card-header { padding: 16px 20px; display: flex; justify-content: space-between; align-items: flex-start; border-bottom: 1px solid var(--bg-base); }
  .coin-meta { display: flex; align-items: center; gap: 12px; }
  .coin-icon { width: 36px; height: 36px; border-radius: 50%; }
  .coin-title { font-size: 18px; font-weight: 700; color: var(--text-primary); line-height: 1.2; }
  .coin-vol { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
   
  .price-meta { text-align: right; }
  .price-main { font-size: 20px; font-family: 'JetBrains Mono'; font-weight: 700; color: var(--text-primary); }
  .price-change { font-size: 13px; font-weight: 500; margin-top: 2px;}
  .c-up { color: var(--binance-green); } .c-down { color: var(--binance-red); }

  /* Matrix Bar */
  .matrix-strip { display: flex; gap: 3px; padding: 6px 20px; background: var(--bg-base); }
  .m-dot { flex: 1; height: 5px; border-radius: 2px; background: var(--bg-hover); transition: 0.3s; }
   
  /* UPDATED: Matrix Dot States */
  .m-dot.bull { background: var(--binance-green); box-shadow: 0 0 5px var(--binance-green); }
  .m-dot.bear { background: var(--binance-red); box-shadow: 0 0 5px var(--binance-red); }
  .m-dot.active { height: 7px; margin-top: -1px; border: 1px solid #fff; }
  .m-dot.prepare { background: #FF9800; box-shadow: 0 0 5px #FF9800; }
   
  /* NEW: Blinking States for Take Profit / Surge */
  .m-dot.blink-green { background: var(--binance-green); box-shadow: 0 0 8px var(--binance-green); animation: blink-fast 0.5s infinite; }
  .m-dot.blink-red { background: var(--binance-red); box-shadow: 0 0 8px var(--binance-red); animation: blink-fast 0.5s infinite; }

  /* Chart Area (TALLER) */
  .chart-container { height: 240px; width: 100%; position: relative; background: var(--bg-base); border-bottom: 1px solid var(--bg-base); }
  .visual-arrow { position: absolute; top: 15px; right: 15px; font-size: 24px; z-index: 5; opacity: 0; pointer-events: none; font-weight: 900; }
  .visual-arrow.buy { color: var(--binance-green); opacity: 1; animation: bounceUp 1s infinite; }
  .visual-arrow.sell { color: var(--binance-red); opacity: 1; animation: bounceDown 1s infinite; }
  .visual-arrow.prepare { color: #FF9800; opacity: 1; animation: blink-slow 1s infinite; content: "‚ö†"; }
  @keyframes bounceUp { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
  @keyframes bounceDown { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(6px); } }

  /* Data Row */
  .data-row { display: grid; grid-template-columns: 1fr 1fr 1fr; padding: 14px 20px; gap: 10px; font-family: 'JetBrains Mono'; }
  .data-item { display: flex; flex-direction: column; gap: 4px; }
  .d-label { font-size: 11px; color: var(--text-secondary); text-transform: uppercase; font-weight: 600; }
  .d-val { font-size: 14px; font-weight: 600; color: var(--text-primary); transition: color 0.2s; }
   
  /* Alarm Animations */
  @keyframes blink-slow { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
  @keyframes blink-fast { 0% { opacity: 1; transform: scale(1); } 25% { opacity: 0.5; transform: scale(1.1); } 50% { opacity: 1; transform: scale(1.2); filter: brightness(1.5); } 100% { opacity: 1; transform: scale(1); } }
   
  .alarm-icon { margin-left: 8px; font-size: 16px; display: none; cursor:help; }
  .alarm-active-slow { display: inline-block; color: var(--binance-green); animation: blink-slow 2s infinite ease-in-out; }
  .alarm-active-fast { display: inline-block; color: var(--accent); text-shadow: 0 0 12px var(--accent); animation: blink-fast 0.25s infinite; }
  .alarm-sell-slow { display: inline-block; color: var(--binance-red); animation: blink-slow 2s infinite ease-in-out; }
  .alarm-sell-fast { display: inline-block; color: #ff0000; text-shadow: 0 0 12px #ff0000; animation: blink-fast 0.25s infinite; }

  /* Action Footer */
  .card-footer { padding: 16px 20px; display: flex; gap: 15px; background: var(--bg-card); }
  .btn-trade { flex: 1; border: none; border-radius: 4px; padding: 12px 0; font-size: 14px; font-weight: 700; cursor: pointer; text-align: center; text-decoration: none; color: white; transition: 0.2s; opacity: 0.3; letter-spacing: 0.5px; }
  .btn-trade.buy { background: var(--binance-green); }
  .btn-trade.sell { background: var(--binance-red); }
  .btn-trade.active { opacity: 1; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
  .btn-trade:hover { opacity: 0.9; }

  /* Loading Overlay */
  #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-base); z-index: 9999; display: flex; align-items: center; justify-content: center; flex-direction: column; }
  .spinner { width: 50px; height: 50px; border: 5px solid var(--bg-hover); border-top: 5px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

  /* --- TABLE & SETTINGS --- */
  .table-wrapper { background: var(--bg-card); border-radius: var(--card-radius); overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
  table { width: 100%; border-collapse: collapse; min-width: 800px; }
  th { text-align: left; padding: 18px 24px; color: var(--text-secondary); font-size: 13px; font-weight: 600; background: var(--bg-base); border-bottom: 2px solid var(--border); }
  td { padding: 18px 24px; border-top: 1px solid var(--border); color: var(--text-primary); font-size: 14px; }
  tr:hover td { background: var(--bg-hover); }
   
  .settings-box { max-width: 600px; margin: 40px auto; background: var(--bg-card); padding: 40px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
  input, textarea { width: 100%; background: var(--bg-base); border: 1px solid #474d57; color: white; padding: 12px; border-radius: 4px; font-family: inherit; margin-bottom: 20px; font-size: 14px; }
  input:focus, textarea:focus { border-color: var(--accent); }
  label { font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; display: block; font-weight: 500; }
  .btn-primary { width: 100%; background: var(--accent); color: #000; font-weight: 700; padding: 14px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: 0.2s; }
  .btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }

  /* Toast Notification */
  #toast-container { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); z-index: 1000; pointer-events: none; }
  .toast { background: #333; color: #fff; padding: 12px 24px; border-radius: 30px; margin-bottom: 10px; font-size: 14px; opacity: 0; transition: opacity 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.4); text-align: center; font-weight: 500; }
  .toast.show { opacity: 1; }

  /* --- RESPONSIVE MEDIA QUERIES --- */
  @media (max-width: 768px) {
      .navbar-top { display: none; }
      .navbar-bottom { display: flex; }
      .main-content { padding: 15px 10px; }
      .grid { grid-template-columns: 1fr; } /* 1 Column on Mobile */
      .card { border-radius: 8px; }
      .chart-container { height: 220px; } 
      .coin-title { font-size: 16px; }
      .price-main { font-size: 18px; }
  }
</style>
</head>
<body>

<!-- LOADING OVERLAY -->
<div id="loading-overlay">
    <div class="spinner"></div>
    <div style="font-family:'JetBrains Mono'; color:var(--text-secondary); font-size:14px; font-weight:600;">ENHANCING LOGIC...</div>
</div>

<!-- TOAST CONTAINER -->
<div id="toast-container"></div>

<!-- DESKTOP TOP HEADER -->
<header class="navbar-top">
    <div class="brand">ZAVANA<span>PRO</span></div>
    <div class="nav-links">
        <div class="nav-link active" onclick="showPage('dashboard', this)">Dashboard</div>
        <div class="nav-link" onclick="showPage('screener', this)">Markets</div>
        <div class="nav-link" onclick="showPage('settings', this)">Settings</div>
    </div>
    <div class="nav-actions">
        <button id="wakeLockBtn" class="action-btn wakelock-btn" onclick="toggleWakeLock()">‚ö° ACTIVE</button>
        <button id="cloudBtn" class="action-btn cloud-btn" onclick="toggleCloudSync()">‚òÅ SYNC</button>
    </div>
</header>

<!-- MAIN CONTENT -->
<main class="main-content">
    
    <!-- PAGE 1: DASHBOARD -->
    <div id="page-dashboard" class="page active">
        <div class="toolbar-container">
            <div id="strategyLabel" class="strategy-badge">INIT SYSTEM...</div>
            <div class="toolbar-group" id="tfToolbar"></div>
        </div>

        <div class="grid" id="grid">
            <!-- CARDS INJECTED HERE -->
        </div>
    </div>

    <!-- PAGE 2: MARKETS -->
    <div id="page-screener" class="page">
        <h2 style="font-weight:500; margin-bottom:20px; font-size:24px;">Market Overview</h2>
        <div class="table-wrapper" style="overflow-x:auto;">
            <table>
                <thead>
                    <tr>
                        <th>Pair</th>
                        <th>Price</th>
                        <th>Trend</th>
                        <th>1m</th> <th>5m</th> <th>1H</th> <th>4H</th> <th>1D</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="screenerTable"></tbody>
            </table>
        </div>
    </div>

    <!-- PAGE 3: SETTINGS -->
    <div id="page-settings" class="page">
        <div class="settings-box">
            <h3 style="margin-top:0; border-bottom:1px solid var(--border); padding-bottom:20px; margin-bottom:30px; font-size:20px;">Preferences</h3>
            
            <label>Watchlist (USDT Pairs, Comma Separated)</label>
            <textarea id="coinInput" rows="4"></textarea>
            
            <label>EmailJS Service ID</label>
            <input type="text" id="emailServiceId">
            <label>EmailJS Template ID</label>
            <input type="text" id="emailTemplateId">
            <label>EmailJS Public Key</label>
            <input type="text" id="emailPublicKey">
            
            <button class="btn-primary" onclick="saveSettings()">Save Configuration</button>
            <div style="text-align:center; margin-top:20px; font-size:12px; color:var(--text-secondary);">
                User ID: <span id="uidDisplay">Local Session</span>
            </div>
        </div>
    </div>

</main>

<!-- MOBILE BOTTOM NAV -->
<nav class="navbar-bottom">
    <div class="mobile-nav-item active" onclick="showPage('dashboard', this)">
        <svg viewBox="0 0 24 24"><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"/></svg>
        <span>Home</span>
    </div>
    <div class="mobile-nav-item" onclick="showPage('screener', this)">
        <svg viewBox="0 0 24 24"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/></svg>
        <span>Markets</span>
    </div>
    <div class="mobile-nav-item" onclick="showPage('settings', this)">
        <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l2.49-1c-.23-.09-.49 0-.61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
        <span>Config</span>
    </div>
</nav>

<script>
/* =========================================
   CORE CONFIG
   ========================================= */
const DEFAULT_COINS = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "XRPUSDT", "DOGEUSDT", "ADAUSDT", "XAUTUSDT", "PAXGUSDT"]; 
let COINS;
try {
    COINS = JSON.parse(localStorage.getItem('zavana_coins'));
    if (!Array.isArray(COINS) || COINS.length === 0) throw new Error("Empty coins");
} catch (e) {
    COINS = DEFAULT_COINS;
    localStorage.setItem('zavana_coins', JSON.stringify(DEFAULT_COINS));
}

let EMAIL_CONFIG;
try {
    EMAIL_CONFIG = JSON.parse(localStorage.getItem('zavana_email_config')) || { serviceId: '', templateId: '', publicKey: '' };
} catch(e) {
    EMAIL_CONFIG = { serviceId: '', templateId: '', publicKey: '' };
}

// TIMEFRAMES CONFIG
const TIMEFRAMES = [
  { label: '1m',  ws: '1m',  cc: 'histominute', limit: 500, agg: 1, type: 'HYPER' }, 
  { label: '5m',  ws: '5m',  cc: 'histominute', limit: 500, agg: 5, type: 'SCALP' },
  { label: '15m', ws: '15m', cc: 'histominute', limit: 500, agg: 15, type: 'DAY' },
  { label: '1H',  ws: '1h',  cc: 'histohour',   limit: 500, agg: 1, type: 'DAY' },
  { label: '4H',  ws: '4h',  cc: 'histohour',   limit: 500, agg: 4, type: 'SWING' },
  { label: '1D',  ws: '1d',  cc: 'histoday',    limit: 500, agg: 1, type: 'INVEST' },
  { label: '1W',  ws: '1w',  cc: 'histoday',    limit: 500, agg: 7, type: 'INVEST' }
];

let CURRENT_TF = TIMEFRAMES[2]; 
let ws = null;
const charts = new Map();
const marketData = new Map();
const MTF_MATRIX = new Map(); 
const analysisResults = new Map(); 
const audioCooldown = new Map(); 
const lastAnalysisTime = new Map(); 
let wakeLock = null;

const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;

/* =========================================
   UI & NAVIGATION
   ========================================= */
function startApp() {
    try {
        renderToolbar();
        renderGrid();
        initSettingsForm(); 
        if(typeof emailjs !== 'undefined' && EMAIL_CONFIG.publicKey) {
            emailjs.init(EMAIL_CONFIG.publicKey);
        }
        changeTimeframe(CURRENT_TF);
        setInterval(updateScreenerTable, 2000); 
        startMatrixScanner();
        setTimeout(() => {
            document.getElementById('loading-overlay').style.display = 'none';
        }, 1000);
    } catch(e) {
        console.error("App Crash:", e);
        document.getElementById('loading-overlay').style.display = 'none';
        showToast("System Init Warning: Check Console");
    }
}

function showToast(message) {
    const container = document.getElementById('toast-container');
    const el = document.createElement('div');
    el.className = 'toast';
    el.textContent = message;
    container.appendChild(el);
    setTimeout(() => el.classList.add('show'), 10);
    setTimeout(() => {
        el.classList.remove('show');
        setTimeout(() => el.remove(), 300);
    }, 3000);
}

function copyText(text) {
    if(!text || text === '--') return;
    const el = document.createElement('textarea');
    el.value = text;
    document.body.appendChild(el);
    el.select();
    document.execCommand('copy');
    document.body.removeChild(el);
    showToast(`Copied: ${text}`);
}

window.showPage = function(pageId, el) {
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.getElementById(`page-${pageId}`).classList.add('active');
    document.querySelectorAll('.nav-link').forEach(n => n.classList.remove('active'));
    if(el && el.classList.contains('nav-link')) el.classList.add('active');
    document.querySelectorAll('.mobile-nav-item').forEach(n => n.classList.remove('active'));
    if(el && el.classList.contains('mobile-nav-item')) el.classList.add('active');
    if(pageId === 'screener') updateScreenerTable();
}

function renderToolbar() {
    const bar = document.getElementById('tfToolbar');
    bar.innerHTML = '';
    TIMEFRAMES.forEach(tf => {
        const btn = document.createElement('button');
        btn.className = `tf-btn ${tf.label === CURRENT_TF.label ? 'active' : ''}`;
        btn.textContent = tf.label;
        btn.onclick = () => changeTimeframe(tf);
        bar.appendChild(btn);
    });
}

function renderGrid() {
    const grid = document.getElementById('grid');
    grid.innerHTML = ''; 
    COINS.forEach(sym => {
        const s = sym.trim().toUpperCase();
        const base = s.replace('USDT','');
        const isGold = s === "PAXGUSDT" || s === "XAUTUSDT";
        let icon = `https://assets.coincap.io/assets/icons/${base.toLowerCase()}@2x.png`;
        if (s === "PAXGUSDT") icon = "https://assets.coincap.io/assets/icons/paxg@2x.png";
        if (s === "XAUTUSDT") icon = "https://s2.coinmarketcap.com/static/img/coins/64x64/5186.png"; 
         
        const card = document.createElement('div');
        card.className = 'card';
        card.id = `card-${s}`;
        card.innerHTML = `
            <div class="sniper-tag" id="tag-${s}">INIT...</div>
            <div class="card-header">
                <div class="coin-meta">
                    <img src="${icon}" class="coin-icon" onerror="this.style.display='none'">
                    <div>
                        <div class="coin-title" style="${isGold?'color:var(--gold)':''}">
                            ${base}/USDT <span id="trend-arrow-${s}" style="font-weight:bold; font-size:14px; margin-left:4px;"></span>
                            ${isGold ? '<span style="font-size:10px; background:#FFD700; color:black; padding:1px 3px; border-radius:2px; margin-left:4px;">GOLD</span>' : ''}
                        </div>
                        <div class="coin-vol">Vol: <span id="vol-${s}">--</span></div>
                    </div>
                </div>
                <div class="price-meta">
                    <div class="price-main" id="price-${s}">---</div>
                    <div class="price-change" id="chg-${s}">--%</div>
                </div>
            </div>
            
            <div class="matrix-strip">
                ${TIMEFRAMES.map(t => `<div id="mtx-${s}-${t.label}" class="m-dot" title="${t.label}"></div>`).join('')}
            </div>

            <div class="chart-container">
                <div id="chart-${s}" style="width:100%; height:100%"></div>
                <div id="visual-${s}" class="visual-arrow">‚û§</div>
            </div>
            
            <div class="data-row">
                <div class="data-item">
                    <span class="d-label">Entry</span>
                    <span class="d-val" id="e-${s}">--</span>
                </div>
                <div class="data-item">
                    <span class="d-label">Stop Loss</span>
                    <span class="d-val" id="sl-${s}">--</span>
                </div>
                <div class="data-item" style="text-align:right;">
                    <span class="d-label">Take Profit</span>
                    <div>
                        <span class="d-val" id="tp-${s}" style="color:var(--binance-green);">--</span>
                        <span id="alarm-${s}" class="alarm-icon">üîî</span>
                    </div>
                </div>
            </div>

            <div class="card-footer">
                <a href="https://www.binance.com/en/trade/${base}_USDT?type=spot" target="_blank" class="btn-trade buy" id="btn-buy-${s}">BUY <span id="sc-buy-${s}">0.0</span></a>
                <a href="https://www.binance.com/en/trade/${base}_USDT?type=spot" target="_blank" class="btn-trade sell" id="btn-sell-${s}">SELL <span id="sc-sell-${s}">0.0</span></a>
            </div>
        `;
        grid.appendChild(card);
        
        // Chart Setup
        const cont = document.getElementById(`chart-${s}`);
        const chart = LightweightCharts.createChart(cont, {
            layout: { backgroundColor: '#0b0e11', textColor: '#848e9c', fontSize: 11, fontFamily: 'JetBrains Mono' }, 
            grid: { vertLines: { color: '#1e2329' }, horzLines: { color: '#1e2329' } },
            rightPriceScale: { borderVisible: false, scaleMargins: { top: 0.1, bottom: 0.1 } },
            timeScale: { visible: false, borderVisible: false },
            crosshair: { vertLine: { visible: false }, horzLine: { visible: false } },
            handleScroll: false, handleScale: false
        });
        const candleColorUp = isGold ? '#FFD700' : '#0ECB81'; 
        const series = chart.addCandlestickSeries({ upColor: candleColorUp, downColor: '#F6465D', borderVisible: false, wickVisible: true });
        const ema = chart.addLineSeries({ color: '#FCD535', lineWidth:1, crosshairMarkerVisible: false }); 

        // === NEW: SUPPORT & RESISTANCE VISUAL LINES ===
        const supportSeries = chart.addLineSeries({ color: '#0ECB81', lineWidth: 1, lineStyle: 2, crosshairMarkerVisible: false, lastValueVisible: false, priceLineVisible: false });
        const resistSeries = chart.addLineSeries({ color: '#F6465D', lineWidth: 1, lineStyle: 2, crosshairMarkerVisible: false, lastValueVisible: false, priceLineVisible: false });
        
        new ResizeObserver(e => { if(e[0]) chart.applyOptions({ width: e[0].contentRect.width, height: e[0].contentRect.height }); }).observe(cont);
        
        charts.set(s, { chart, series, ema, supportSeries, resistSeries });
        marketData.set(s, []);
    });
}

function updateScreenerTable() {
    const tbody = document.getElementById('screenerTable');
    if(!document.getElementById('page-screener').classList.contains('active')) return;
    
    let html = '';
    COINS.forEach(sym => {
        const res = analysisResults.get(sym) || {};
        const base = sym.replace('USDT','');
        const trendClass = res.trend === 'BULLISH' ? 'c-up' : 'c-down';
        const getMtxColor = (tf) => {
            const rawSig = MTF_MATRIX.get(`${sym}_${tf}`) || 'WAIT';
            const sig = rawSig.replace('_SURGE', '');
            if (sig === 'PREPARE') return 'color:#FF9800; font-weight:bold;'; // PREPARE COLOR
            return sig === 'BUY' ? 'color:var(--binance-green); font-weight:bold;' : (sig === 'SELL' ? 'color:var(--binance-red); font-weight:bold;' : 'color:var(--text-secondary); opacity:0.3;');
        };

        html += `
            <tr style="border-bottom:1px solid var(--border);">
                <td><b style="color:var(--text-primary);">${base}</b></td>
                <td style="font-family:'JetBrains Mono';">${res.price ? res.price.toFixed(res.price<1?4:2) : '---'}</td>
                <td class="${trendClass}" style="font-size:11px;">${res.trend || 'WAIT'}</td>
                <td style="${getMtxColor('1m')}">‚óè</td>
                <td style="${getMtxColor('5m')}">‚óè</td>
                <td style="${getMtxColor('1H')}">‚óè</td>
                <td style="${getMtxColor('4H')}">‚óè</td>
                <td style="${getMtxColor('1D')}">‚óè</td>
                <td><a href="https://www.binance.com/en/trade/${base}_USDT" target="_blank" style="color:var(--accent); text-decoration:none;">TRADE</a></td>
            </tr>
        `;
    });
    tbody.innerHTML = html;
}

/* =========================================
   DATA & STRATEGY (UPDATED WITH USER RUMUS)
   ========================================= */
async function changeTimeframe(tf) {
    CURRENT_TF = tf;
    document.querySelectorAll('.tf-btn').forEach(b => b.classList.toggle('active', b.textContent === tf.label));
    
    const sLabel = document.getElementById('strategyLabel');
    sLabel.textContent = `MODE: ${tf.type} (${tf.label})`;
    sLabel.style.color = tf.type==='HYPER' ? 'var(--binance-red)' : 'var(--text-primary)';
    
    if(ws) ws.close();
    
    for (const sym of COINS) {
        // === SMART DELAY: Avoid Rate Limits on Fallback API ===
        await new Promise(r => setTimeout(r, 1000)); 
        
        const hist = await fetchHistory(sym, tf.ws, tf.limit);
        if(hist && hist.length > 0) { // Safety check for empty data
            marketData.set(sym, hist);
            const cObj = charts.get(sym);
            if(cObj) {
                cObj.series.setData(hist);
                cObj.ema.setData(calcEMAData(hist, 200));
                // CRITICAL FIX: Ensure chart fits content after data load
                cObj.chart.timeScale().fitContent(); 
                analyze(sym, hist, tf);
            }
        }
    }
    
    const streams = COINS.map(c => `${c.toLowerCase()}@kline_${tf.ws}`).join('/');
    ws = new WebSocket(`wss://stream.binance.com:9443/stream?streams=${streams}`);
    ws.onmessage = (e) => {
        try {
            const msg = JSON.parse(e.data);
            const k = msg.data.k;
            const c = { time: k.t/1000, open: +k.o, high: +k.h, low: +k.l, close: +k.c, volume: +k.v };
            handleStream(msg.data.s, c);
        } catch(err) {}
    };
}

// CHANGED: 3-Stage Fetch Strategy (Direct -> Proxy -> Backup)
async function fetchHistory(s, interval, lim) {
    // Stage 1: Binance Direct
    try {
        const url = `https://api.binance.com/api/v3/klines?symbol=${s}&interval=${interval}&limit=${lim}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Binance Blocked");
        return await parseBinance(res);
    } catch(e) { 
        // Stage 2: Binance via Proxy
        try {
             const url = `https://api.binance.com/api/v3/klines?symbol=${s}&interval=${interval}&limit=${lim}`;
             const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
             const res = await fetch(proxyUrl);
             if (!res.ok) throw new Error("Proxy Blocked");
             return await parseBinance(res);
        } catch (e2) {
             console.warn("Binance Proxy failed, switching to CryptoCompare...");
             // Stage 3: CryptoCompare Backup
             return await fetchHistoryBackup(s, interval, lim);
        }
    }
}

async function parseBinance(res) {
    const raw = await res.json();
    if (!Array.isArray(raw) || raw.length === 0) throw new Error("Empty Data"); // FORCE BACKUP IF EMPTY
    return raw.map(d => ({
        time: d[0] / 1000,
        open: parseFloat(d[1]),
        high: parseFloat(d[2]),
        low: parseFloat(d[3]),
        close: parseFloat(d[4]),
        volume: parseFloat(d[5])
    }));
}

// UPDATED: Smart Fallback (USDT -> USD)
async function fetchHistoryBackup(s, interval, lim) {
    let endpoint = 'histominute';
    let agg = 1;
    if(interval === '1m') { endpoint = 'histominute'; agg = 1; }
    if(interval === '5m') { endpoint = 'histominute'; agg = 5; }
    if(interval === '15m') { endpoint = 'histominute'; agg = 15; }
    if(interval === '1h') { endpoint = 'histohour'; agg = 1; }
    if(interval === '4h') { endpoint = 'histohour'; agg = 4; }
    if(interval === '1d') { endpoint = 'histoday'; agg = 1; }
    if(interval === '1w') { endpoint = 'histoday'; agg = 7; }

    const base = s.replace('USDT','');
    
    // Helper to fetch and validate
    const tryFetch = async (tsym) => {
        try {
            const res = await fetch(`https://min-api.cryptocompare.com/data/v2/${endpoint}?fsym=${base}&tsym=${tsym}&limit=${lim}&aggregate=${agg}`);
            const j = await res.json();
            if(j.Response === "Error") return null;
            if(!j.Data || !j.Data.Data || j.Data.Data.length === 0) return null;
            return j.Data.Data.map(d=>({time:d.time,open:d.open,high:d.high,low:d.low,close:d.close,volume:d.volumeto}));
        } catch(e) { return null; }
    };

    // 1. Try USDT (Standard)
    let data = await tryFetch('USDT');
    
    // 2. If USDT fails/empty, Try USD (Fallback for Gold/Commodities)
    if (!data) {
        console.warn(`USDT backup failed for ${base}, trying USD...`);
        data = await tryFetch('USD');
    }
    
    return data || [];
}

function handleStream(sym, candle) {
    const arr = marketData.get(sym);
    if(!arr) return;
    const last = arr[arr.length-1];
    
    if (candle.time === last.time) {
        arr[arr.length-1] = candle; 
    } else if (candle.time > last.time) {
        arr.push(candle); 
        if(arr.length > 500) arr.shift();
    }
    
    const pEl = document.getElementById(`price-${sym}`);
    if(pEl) {
        const prev = parseFloat(pEl.getAttribute('data-p')||0);
        if(candle.close !== prev) {
            pEl.textContent = candle.close.toFixed(candle.close<1?4:2);
            pEl.className = `price-main ${candle.close>=prev?'c-up':'c-down'}`;
            pEl.setAttribute('data-p', candle.close);
        }
    }

    const cObj = charts.get(sym);
    if(cObj) cObj.series.update(candle);
    
    const now = Date.now();
    const lastRun = lastAnalysisTime.get(sym) || 0;
    if (now - lastRun > 1000) {
        analyze(sym, arr, CURRENT_TF);
        lastAnalysisTime.set(sym, now);
    }
}

/* =========================================
   REVISED ANALYZE FUNCTION (STRICT LOGIC + DISTANCE FILTER + PRE-SIGNAL)
   ========================================= */
function analyze(sym, data, tf = CURRENT_TF, isBackground = false) {
    if(data.length < 50) return; 

    const last = data[data.length-1];
    const prev = data[data.length-2];
    const atr = calcATR(data, 14); // ATR for distance measurement
    
    // 1. RUMUS 1: ATR (VStop) Cloud
    const vStopBig = calcVolStopSeries(data, 20, 3.0);
    const bigTrend = vStopBig.uptrend; // true = bull, false = bear
    
    // 2. RUMUS 2: Support Band (Structure)
    const sma20 = calcSMA(data, 20);
    const ema21 = calcEMA(data, 21);
    
    // 3. RUMUS 4: OBV Oscillator (Momentum)
    const obvOsc = calcOBVOscillator(data, 10, 10);
    const obvVal = obvOsc[obvOsc.length-1];
    const obvPrev = obvOsc[obvOsc.length-2];
    
    // 4. RUMUS 5 & 3: Order Blocks (Structure)
    const smc = findOrderBlocksAdvanced(data, 5); 

    // === NEW LOGIC: PRE-SIGNAL & DISTANCE FILTER ===
    let signal = 'WAIT';
    
    // --- STEP A: IDENTIFY STRUCTURE PROXIMITY (Distance to Band or OB) ---
    // Define the "Key Level" for the current trend
    let structureLevel = 0;
    if (bigTrend) {
        // In Uptrend, structure is Demand (OB Bull) or Support Band
        structureLevel = smc.bullOB ? smc.bullOB.top : Math.max(sma20, ema21);
    } else {
        // In Downtrend, structure is Supply (OB Bear) or Resistance Band
        structureLevel = smc.bearOB ? smc.bearOB.bottom : Math.min(sma20, ema21);
    }
    
    // Calculate Distance (Absolute difference)
    const distanceToStructure = Math.abs(last.close - structureLevel);
    // Threshold: If price is > 1.5 ATR away from structure, it's "Far" (Pucuk Risk)
    const isFar = distanceToStructure > (atr * 1.5);
    const isNear = distanceToStructure <= (atr * 1.0); // "Safe Zone"

    // --- STEP B: DETECT MARKET INTENT (PRE-SIGNAL) ---
    // We want to catch the move BEFORE it happens (at the structure)
    // "Prepare" if Price is NEAR structure AND Momentum is Resetting (Oversold in Uptrend / Overbought in Downtrend)
    let isIntent = false;
    
    if (bigTrend) {
        // Uptrend: Looking for dip into support with Oversold momentum
        if (isNear && obvVal < -40) isIntent = true; 
        // Also check if touching OB
        if (smc.bullOB && last.low <= smc.bullOB.top && last.close >= smc.bullOB.bottom) isIntent = true;
    } else {
        // Downtrend: Looking for rally into resistance with Overbought momentum
        if (isNear && obvVal > 40) isIntent = true;
        if (smc.bearOB && last.high >= smc.bearOB.bottom && last.close <= smc.bearOB.top) isIntent = true;
    }

    // --- STEP C: EXECUTION LOGIC ---
    if (isIntent) {
        signal = 'PREPARE'; // Yellow Alert: "Siap-siap, Niat Market Terdeteksi"
    } 
    
    // Upgrade to BUY/SELL only if confirmation candle appears AND not too far
    if (bigTrend) {
        if (last.close > prev.close && obvVal > obvPrev && !isFar) {
             // Confirmation exists. But was there intent? 
             // If we are just launching from structure, it's a BUY
             signal = 'BUY';
        } else if (isFar) {
             signal = 'WAIT'; // Cancel signal if too far (Pucuk prevention)
        }
    } else {
        if (last.close < prev.close && obvVal < obvPrev && !isFar) {
             signal = 'SELL';
        } else if (isFar) {
             signal = 'WAIT';
        }
    }
    
    // Override: If intent is strong but candle isn't confirming yet, keep it PREPARE
    if (signal === 'BUY' && obvVal < -40) signal = 'PREPARE'; // Still heavy oversold, wait for turn
    if (signal === 'SELL' && obvVal > 40) signal = 'PREPARE';

    // Store Matrix
    const matrixSig = signal;
    MTF_MATRIX.set(`${sym}_${tf.label}`, matrixSig);
    
    if (isBackground) { updateMatrixUI(sym); return; }

    // --- SL/TP CALCULATION ---
    let tp = 0, sl = 0;
    
    if(signal === 'BUY' || signal === 'PREPARE') {
        sl = structureLevel - (atr * 1.5); // SL below structure
        tp = last.close + (atr * 3);
    } else if(signal === 'SELL' || signal === 'PREPARE') {
        sl = structureLevel + (atr * 1.5); // SL above structure
        tp = last.close - (atr * 3);
    }

    const res = { signal, trend: bigTrend ? 'BULLISH' : 'BEARISH', price: last.close, open: last.open, tp, sl, dist: distanceToStructure, isFar };
    analysisResults.set(sym, res);
    
    // VISUAL UPDATE
    const cObj = charts.get(sym);
    if(cObj) {
        // Visualize Structure Level
        if (bigTrend) cObj.supportSeries.setData(data.map(d => ({ time: d.time, value: structureLevel })));
        else cObj.resistSeries.setData(data.map(d => ({ time: d.time, value: structureLevel })));
        
        let markers = [];
        // OB Markers
        if (smc.bullOB) markers.push({ time: smc.bullOB.time, position: 'belowBar', color: 'cyan', shape: 'circle', text: 'OB' });
        if (smc.bearOB) markers.push({ time: smc.bearOB.time, position: 'aboveBar', color: 'orange', shape: 'circle', text: 'OB' });

        // Signal Markers
        if(signal === 'BUY') markers.push({ time: last.time, position: 'belowBar', color: '#0ECB81', shape: 'arrowUp', text: 'BUY' });
        else if(signal === 'SELL') markers.push({ time: last.time, position: 'aboveBar', color: '#F6465D', shape: 'arrowDown', text: 'SELL' });
        else if(signal === 'PREPARE') markers.push({ time: last.time, position: bigTrend?'belowBar':'aboveBar', color: '#FF9800', shape: 'circle', text: '‚ö†' });
        
        cObj.series.setMarkers(markers);
    }
    
    updateCardUI(sym, res, (Math.abs(last.close-last.open) > atr*2), false);
    updateMatrixUI(sym);
    // Trigger Alert on PREPARE (Intent) and EXECUTE
    if(signal !== 'WAIT') triggerAlert(sym, signal);
}

/* =========================================
   NEW MATHEMATICAL HELPERS (FROM RUMUS)
   ========================================= */

// RUMUS 1: ATR (VStop) Calculation
function calcVolStopSeries(data, length, factor) {
    let max = data[0].close;
    let min = data[0].close;
    let uptrend = true;
    let stop = data[0].close - (calcTR(data[0], data[0]) * factor);
    
    // Iterate to find current state
    for(let i=1; i<data.length; i++) {
        const curr = data[i];
        const prev = data[i-1];
        const tr = Math.max(curr.high - curr.low, Math.abs(curr.high - prev.close), Math.abs(curr.low - prev.close));
        // Simple ATR approx for efficiency in loop
        const atrM = tr * factor; // Simplified for loop, strictly ideally should use smoothed ATR
        
        max = Math.max(max, curr.close);
        min = Math.min(min, curr.close);
        
        if (uptrend) {
            stop = Math.max(stop, max - atrM);
        } else {
            stop = Math.min(stop, min + atrM);
        }
        
        const newUptrend = (curr.close - stop) >= 0;
        if (newUptrend !== uptrend) {
            max = curr.close;
            min = curr.close;
            uptrend = newUptrend;
            stop = uptrend ? max - atrM : min + atrM;
        }
    }
    return { stop, uptrend };
}

function calcTR(curr, prev) {
    return Math.max(curr.high - curr.low, Math.abs(curr.high - prev.close), Math.abs(curr.low - prev.close));
}

// RUMUS 4: OBV Oscillator
function calcOBVOscillator(data, n1, n2) {
    // OBV
    let obv = [0];
    for(let i=1; i<data.length; i++) {
        const change = data[i].close - data[i-1].close;
        const sign = change > 0 ? 1 : (change < 0 ? -1 : 0);
        obv.push(obv[i-1] + (sign * data[i].volume));
    }
    
    // EMA of OBV (n1)
    const emaOBV = calcEMAArray(obv, n1);
    
    // Abs Diff EMA
    let absDiff = [];
    for(let i=0; i<obv.length; i++) {
        absDiff.push(Math.abs(obv[i] - emaOBV[i]));
    }
    const emaAbsDiff = calcEMAArray(absDiff, n1);
    
    // OUT Calculation
    let out = [];
    for(let i=0; i<obv.length; i++) {
        const denom = 0.015 * emaAbsDiff[i];
        if (denom === 0) out.push(0);
        else out.push( (obv[i] - emaOBV[i]) / denom );
    }
    
    // Final EMA Smoothing (n2)
    return calcEMAArray(out, n2);
}

function calcEMAArray(dataArr, period) {
    let results = [];
    let k = 2 / (period + 1);
    let ema = dataArr[0];
    results.push(ema);
    for(let i=1; i<dataArr.length; i++) {
        ema = (dataArr[i] * k) + (ema * (1 - k));
        results.push(ema);
    }
    return results;
}

// RUMUS 5 & 3: Advanced Order Block & Swing Finder
function findOrderBlocksAdvanced(data, periods = 5) {
    if(data.length < 50) return {};
    let swings = { highs: [], lows: [] };
    
    // Pivot High/Low (Rumus 3)
    let lastSwingHigh = 0;
    let lastSwingLow = 0;
    
    // Order Blocks (Rumus 5 Logic: Down candle before X Up candles)
    let bullOB = null;
    let bearOB = null;

    // Scan backwards to find latest valid OB
    // ob_period is index of potential OB
    // We need 'periods' (5) subsequent candles to confirm
    
    for(let i = data.length - 1 - periods; i > 1; i--) {
        const obCandle = data[i];
        
        // Check Bullish OB (Red candle followed by 5 Greens)
        if (!bullOB && obCandle.close < obCandle.open) { // Is Red
            let allGreen = true;
            for(let j=1; j<=periods; j++) {
                if(data[i+j].close <= data[i+j].open) allGreen = false;
            }
            // Logic: Is Relevant Move? (Threshold check implied)
            if(allGreen) {
                bullOB = { 
                    top: Math.max(obCandle.open, obCandle.close), 
                    bottom: obCandle.low, // Use Low as per Rumus
                    avg: (Math.max(obCandle.open, obCandle.close) + obCandle.low) / 2,
                    time: obCandle.time // === ADDED TIME FOR MARKER ===
                };
            }
        }
        
        // Check Bearish OB (Green candle followed by 5 Reds)
        if (!bearOB && obCandle.close > obCandle.open) { // Is Green
            let allRed = true;
            for(let j=1; j<=periods; j++) {
                if(data[i+j].close >= data[i+j].open) allRed = false;
            }
            if(allRed) {
                bearOB = { 
                    top: obCandle.high, // Use High as per Rumus
                    bottom: Math.min(obCandle.open, obCandle.close),
                    avg: (obCandle.high + Math.min(obCandle.open, obCandle.close)) / 2,
                    time: obCandle.time // === ADDED TIME FOR MARKER ===
                };
            }
        }
        
        // Pivot Logic (Simple 5-bar fractal)
        if(i > 5 && i < data.length - 5) {
            const isHigh = data[i].high > data[i-1].high && data[i].high > data[i-2].high && data[i].high > data[i+1].high && data[i].high > data[i+2].high;
            if(isHigh) lastSwingHigh = data[i].high;
            
            const isLow = data[i].low < data[i-1].low && data[i].low < data[i-2].low && data[i].low < data[i+1].low && data[i].low < data[i+2].low;
            if(isLow) lastSwingLow = data[i].low;
        }
        
        if(bullOB && bearOB && lastSwingHigh && lastSwingLow) break;
    }

    return { bullOB, bearOB, lastSwingHigh, lastSwingLow };
}

// Helpers
function calcSMA(d, p) { if(d.length<p) return d[d.length-1].close; let s=0; for(let i=d.length-p; i<d.length; i++) s+=d[i].close; return s/p; }
function calcEMA(d,p){if(d.length<p)return null;const k=2/(p+1);let e=d[0].close;for(let i=1;i<d.length;i++)e=(d[i].close*k)+(e*(1-k));return e;}
function calcATR(d,p){if(d.length<p+1)return 0;let s=0;for(let i=d.length-p;i<d.length;i++)s+=Math.max(d[i].high-d[i].low,Math.abs(d[i].high-d[i-1].close),Math.abs(d[i].low-d[i-1].close));return s/p;}
function calcEMAData(d,p){let r=[];if(d.length<p)return r;const k=2/(p+1);let e=d[0].close;for(let i=0;i<d.length;i++){e=(d[i].close*k)+(e*(1-k));if(i>=p)r.push({time:d[i].time,value:e});}return r;}

function updateCardUI(sym, res, isSurge, isChoppy) {
    const card = document.getElementById(`card-${sym}`);
    if(!card) return;

    // Sniper Mode Logic
    const s1 = (MTF_MATRIX.get(`${sym}_1m`)||'').replace('_SURGE','');
    const s5 = (MTF_MATRIX.get(`${sym}_5m`)||'').replace('_SURGE','');
    const isSniper = (s1 === 'BUY' && s5 === 'BUY') || (s1 === 'SELL' && s5 === 'SELL');
    
    if(isSniper && (CURRENT_TF.label === '1m' || CURRENT_TF.label === '5m')) card.classList.add('sniper-mode');
    else card.classList.remove('sniper-mode');

    const tag = card.querySelector('.sniper-tag');
    tag.className = 'sniper-tag'; 
    tag.style.opacity = '1';

    // UI Feedback for Choppy Market
    if (res.signal === 'PREPARE') {
         tag.textContent = 'PANTAU: MARKET INTENT';
         tag.className = 'sniper-tag tag-prepare'; // ORANGE
    } else if (isChoppy && res.signal === 'WAIT') {
         tag.textContent = 'CHOOPY / SIDEWAYS';
         tag.style.background = '#2b3139';
         tag.style.color = '#848e9c';
         tag.style.opacity = '0.7';
    } else if (res.signal === 'BUY') {
        tag.textContent = 'EXECUTE BUY';
        tag.className = 'sniper-tag tag-buy';
    } else if (res.signal === 'SELL') {
        tag.textContent = 'EXECUTE SELL';
        tag.className = 'sniper-tag tag-sell';
    } else {
        tag.className = 'sniper-tag';
        if (res.isFar) {
            tag.textContent = 'RISKY / LATE ENTRY'; // Anti Pucuk Alert
            tag.style.background = '#333';
            tag.style.color = '#FF9800';
        } else if (res.trend === 'BULLISH') {
            tag.textContent = 'TUNGGU KOREKSI';
            tag.classList.add('tag-wait-bull');
        } else {
            tag.textContent = 'TUNGGU PANTULAN';
            tag.classList.add('tag-wait-bear');
        }
    }

    const arrowEl = document.getElementById(`trend-arrow-${sym}`);
    if(arrowEl) {
        if(res.trend === 'BULLISH') {
            arrowEl.innerHTML = '&#8599;'; 
            arrowEl.style.color = 'var(--binance-green)';
        } else {
            arrowEl.innerHTML = '&#8600;'; 
            arrowEl.style.color = 'var(--binance-red)';
        }
    }

    const btnBuy = document.getElementById(`btn-buy-${sym}`);
    const btnSell = document.getElementById(`btn-sell-${sym}`);
    btnBuy.className = `btn-trade buy ${res.signal==='BUY'?'active':''}`;
    btnSell.className = `btn-trade sell ${res.signal==='SELL'?'active':''}`;
    
    // Using scores for intent strength visual if needed, currently fixed text
    document.getElementById(`sc-buy-${sym}`).textContent = "0.0"; 
    document.getElementById(`sc-sell-${sym}`).textContent = "0.0";

    const visualEl = document.getElementById(`visual-${sym}`);
    if(res.signal === 'BUY') { visualEl.textContent = '‚ñ≤'; visualEl.className = 'visual-arrow buy'; }
    else if(res.signal === 'SELL') { visualEl.textContent = '‚ñº'; visualEl.className = 'visual-arrow sell'; }
    else if(res.signal === 'PREPARE') { visualEl.textContent = '‚ö†'; visualEl.className = 'visual-arrow prepare'; }
    else { visualEl.className = 'visual-arrow'; }
    
    const alarmEl = document.getElementById(`alarm-${sym}`);
    const elTP = document.getElementById(`tp-${sym}`);
    const elSL = document.getElementById(`sl-${sym}`);
    
    if(res.signal !== 'WAIT') {
        document.getElementById(`e-${sym}`).textContent = res.price.toFixed(res.price<1?4:2);
        elTP.textContent = res.tp.toFixed(res.price<1?4:2);
        elSL.textContent = res.sl.toFixed(res.price<1?4:2);
        
        if (res.signal === 'BUY') {
            if (alarmEl) {
                if (res.price > res.open) {
                    if (isSurge) alarmEl.className = 'alarm-icon alarm-active-fast'; 
                    else alarmEl.className = 'alarm-icon alarm-active-slow'; 
                } else {
                    alarmEl.className = 'alarm-icon alarm-active-slow'; 
                }
            }
        } else if (res.signal === 'SELL') {
            if (alarmEl) {
                if (res.price < res.open) {
                    if (isSurge) alarmEl.className = 'alarm-icon alarm-sell-fast'; 
                    else alarmEl.className = 'alarm-icon alarm-sell-slow'; 
                } else {
                    alarmEl.className = 'alarm-icon alarm-sell-slow'; 
                }
            }
        } else if (res.signal === 'PREPARE') {
             if (alarmEl) alarmEl.className = 'alarm-icon alarm-active-slow'; // Slow blink for Prepare
        }

        elTP.style.fontWeight = '700';
        elTP.style.fontSize = '14px';
        elSL.style.fontWeight = '700';
        elSL.style.fontSize = '14px';
        elSL.style.color = 'var(--binance-red)';
    } else {
        if(alarmEl) alarmEl.className = 'alarm-icon'; 
        elTP.style.fontWeight = '600';
        elTP.style.fontSize = '12px';
        elSL.style.fontWeight = '600';
        elSL.style.fontSize = '12px';
        elSL.style.color = 'var(--text-primary)';
    }
}

function updateMatrixUI(sym) {
    TIMEFRAMES.forEach(tf => {
        const el = document.getElementById(`mtx-${sym}-${tf.label}`);
        if(el) {
            const rawSig = MTF_MATRIX.get(`${sym}_${tf.label}`) || 'WAIT';
            // Parse Surge Status
            const isSurge = rawSig.includes('_SURGE');
            const sig = rawSig.replace('_SURGE', '');

            if (sig === 'BUY') {
                el.className = isSurge ? 'm-dot blink-green' : 'm-dot bull';
            } else if (sig === 'SELL') {
                el.className = isSurge ? 'm-dot blink-red' : 'm-dot bear';
            } else if (sig === 'PREPARE') {
                el.className = 'm-dot prepare'; // Orange dot
            } else {
                el.className = 'm-dot';
            }
            
            if(tf.label === CURRENT_TF.label) el.classList.add('active');
        }
    });
}

function startMatrixScanner() {
    let coinIdx = 0, tfIdx = 0;
    setInterval(async () => {
        if(COINS.length === 0) return;
        const sym = COINS[coinIdx];
        const tf = TIMEFRAMES[tfIdx];
        
        // Scan other timeframes
        if(tf.label !== CURRENT_TF.label) {
            try {
                // Fetch small chunk of history for efficient scanning
                const hist = await fetchHistory(sym, tf.ws, 60);
                if(hist.length > 50) {
                    // RUN ANALYSIS IN BACKGROUND MODE (isBackground = true)
                    analyze(sym, hist, tf, true);
                }
            } catch(e) {}
        }
        
        // Cycle through coins and timeframes
        tfIdx++;
        if(tfIdx >= TIMEFRAMES.length) { 
            tfIdx = 0; 
            coinIdx++; 
            if(coinIdx >= COINS.length) coinIdx = 0; 
        }
    }, 1000); // Scans 1 asset/timeframe per second
}

/* =========================================
   SETTINGS & UTILS
   ========================================= */
function initSettingsForm() {
    document.getElementById('coinInput').value = COINS.join(', ');
    document.getElementById('emailServiceId').value = EMAIL_CONFIG.serviceId;
    document.getElementById('emailTemplateId').value = EMAIL_CONFIG.templateId;
    document.getElementById('emailPublicKey').value = EMAIL_CONFIG.publicKey;
}
window.saveSettings = function() {
    const raw = document.getElementById('coinInput').value;
    COINS = raw.split(',').map(s => s.trim().toUpperCase()).filter(s => s.length > 0);
    EMAIL_CONFIG.serviceId = document.getElementById('emailServiceId').value;
    EMAIL_CONFIG.templateId = document.getElementById('emailTemplateId').value;
    EMAIL_CONFIG.publicKey = document.getElementById('emailPublicKey').value;
    localStorage.setItem('zavana_coins', JSON.stringify(COINS));
    localStorage.setItem('zavana_email_config', JSON.stringify(EMAIL_CONFIG));
    saveCloudData();
    location.reload(); 
}
async function toggleWakeLock() {
    if ('wakeLock' in navigator) {
        try { wakeLock ? (await wakeLock.release(), wakeLock=null) : (wakeLock=await navigator.wakeLock.request('screen')); } catch(e){}
        const btn = document.getElementById('wakeLockBtn');
        if(wakeLock) { btn.classList.add('active'); btn.innerHTML = '‚ö° ON'; } else { btn.classList.remove('active'); btn.innerHTML = '‚ö° OFF'; }
    }
}
function triggerAlert(sym, type) {
    const now = Date.now();
    if(now - (audioCooldown.get(sym)||0) > 60000) {
        if(Notification.permission==='granted') new Notification(`ZAVANA ${type}: ${sym}`);
        playBeep(); audioCooldown.set(sym, now);
    }
}
async function playBeep() {
    try { if(!audioCtx) audioCtx = new AudioContext(); if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc=audioCtx.createOscillator(), g=audioCtx.createGain(); osc.connect(g); g.connect(audioCtx.destination);
    osc.frequency.setValueAtTime(880,audioCtx.currentTime); g.gain.setValueAtTime(0.05,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.2);
    osc.start(); osc.stop(audioCtx.currentTime+0.2); } catch(e){}
}
document.addEventListener('click', () => { if(!audioCtx) audioCtx = new AudioContext(); });

let auth, db, user;
async function toggleCloudSync() { showToast("Cloud Sync Active (Stub Mode)"); } 
async function saveCloudData() {}

const checkLib = setInterval(() => { if (typeof LightweightCharts !== 'undefined') { clearInterval(checkLib); startApp(); } }, 200);
</script>
</body>
</html>
